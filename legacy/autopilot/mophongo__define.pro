; test validation
; SNR < 1 to SNR > 1000 ok. at bin = 1, convolve at bin=1, kernel at bin=3
; - test background
; - test shift / rotation
; - binning
;   + x3 storage

; badness:
; -> check rotated PSF i=31, 6977
; and   6977, 6898,7214,7225,7238
; -- @@ checked both aor_pa flip and kernel 180 rotation flip -> clearly worse
; -- @@@ need to check PSF orientation -> go back to IRAC Oars, det deep stack (e.g. in HUDF
;     and trace rotations and residuals

; do aperture photometry, instrumental counts

; tasks:
; - photometry
;    + aperture photometry, colors, total
;    + circular, elliptical
; - fitting photometry based on subphot
;   + best-fit (force > positive or not?)
;   + aperture matched photometry: best-fit + inproduct of tmpl + residual map (what is error?)
;   + use covariance matrix? to indicate quality -> check tphot?
;
; - allowed models:
;   + autogenerated from det image (segmap or deblended)
;   + allow reading in a theoretical prior from file (ID_tmpl.fits -> not PSF convolved)
;     get pixel scale from header
;   + unresolved point-like priors: a catalog of positions (ra,dec,or x,y)
;     can decide on point vs not, by examining the FWHM.
;     model type: segment, blend, model, point
;   + select type in input catalog
;
; - no file buffering, just accepts an image and optional header
;   + will do internal buffering for efficiency
;
; - save photometry image in model pixel units
;   + PSF FWHM is sampled by 5 pixels
;   + photometry image is sampled by at least original pixel scale
;
; - PSF: as provided by psf, interpolated coefficients on a grid of ra,dec
;   +, also store original coefficients
;   + allow irregular interpolation if desired
;
; - don't generate for diagnostics for all, only after run for selected.
; @@ write diagnostic viewer, if ying,yang -> regul. check sources with large shifts -> update position
;
; - shifts: faulty shifts ? replace by local interpolated?
;   + cross correlation based on first pass fit
;   + inverse shift the photometry image
;     do not apply the shift we want to fft only once
;
; - kernels: don't recompute for each object.
;   + make map at a 2 finer grid than in PSF map
;   + precompute PSF grid
;   + pull from memory
;
; - extended wings van foreground galaxies.
;
; - FFT convolutions: ignore aliasing, except boundary,
;    + at single precision residuals are at level 1e-7
;      so set a dynamic range threshold of 1e-5 * rms, if higher -> pad x2
;      otherwise use the padding provided by fconvolve (> center array?)
;;
; - TFIT/TPHOT possibilies:
;   +  overlapping grid cell (cells on objects), separate fit and choose the one closer to the center
;   + convphot method: image as a whole (sparse)
;   + cells on objects: sort by brightness, build cell on object enlarge to include overlapping sources.
;     -> subtract object: they claim that because of reducing the catalog by 1 each time -> speed up
;
;    TPHOT: constant background or local background for each source
;
;  MOPHONGO:
;  + flux prior: see tphot_2.0 doc 4.3.5: -> add in quadrature to A and b in A x = b
;    aij = aij + 1/si^2  and Bi = Bi + fi/si^2, where is provided by user
;
;  + the cross correlation and polynomial interpolation: Hogg -> optimal centering
;    - positions -> first moment weighted
;    - then convolve elliptical gaussian within first moments and center fit w polynomial within a fraction of sigma
;
;  + in principle: because we have pixel convolved PSF
;    after building the model and convolving with the pixel convolved kernel
;    in principle.... we only have to *evaluate* at these positionsspare
;    -> check this!!!
;    according to Sampling Theorem we only have to sample low-res image at x2 the pixel size (do 2x to be sure)
;    seek the closest multiple within abs(25%) or the next one up
;
;  + so read in template image, process cut-out
;
;  + so that means if the low-resolution image is a well sampled PSF, we should not have to upsample it much further
;    that's why we want to work in ra dec
;
;  + when feeding it sextractor catalogs -> can let do the prior deblending for you
;
;  + @@@ PCA analysis: EM PCA can include missing data and has complexity (knp) rather than np^2
;    do stars on full image
;
;  - @@@ skysub:
;  + background: check that a reasonable background was always subtracted
;  + fit a bicubic spline with asymtric errors ??
;
; - @@@@ SWarp uses the Bron and Kerbosh algorithm (1973) based on FITS header information
; to estimate the maximum number of input frames that overlap and optimize the
; management of its internal buffers.
;
; AUTOPILOT:
; - @@@@ enable setting a max memory.
;
; - @@@@ crucial: make sure the image background is subtracted well. not under nor over subtracted
;
; @@@ to do:
;    write fit 2 results
;    write id's of objects used in fit
;  - write wrapper that reads a config file, runs a whole catalog, and writes a full catalog
;  - allow to give error image
;  - make option to provide only the 2 PSFs
;  - error estimate on aperture correct kernel?
; also write flux of aperture corrected tmpl

; comments fit residuals: color gradients
;  id 6878 doesnt really improve... -> blended and oversplit source.... 3x oversplit
; IRAC residual might be good diagnostic
; id 6913 in other cases it improves, but one is really fitting resolved colors....
; -> fit these direct with kernel !!!!
; can we parameterize model as a 'color gradient' ?
; 6945 much improved, but still big residual -> again, model color gradient directly ?
; .e.g we probably do not want to use these "improved" fits
; MOPHONGO::FIT_RESIDUALS [DEBUG] tweaking fit 6968 1200.7692 -> 405.28076 : 2.9628081 betteretter
; MOPHONGO::FIT_RESIDUALS [DEBUG] tweaking fit 6977 52.104965 -> 3.3358769 : 15.619571 b
; @@@id 7006 4.6638460 -> 0.35197556 : 13.250483 beautiful ex. merging galaxy with different colors
; @@@ IDEA model color gradient by ratio of phot / model
; tvs,(phot/model)[k4:3*k4,k4:3*k4],mm=[0.7,1.2]*1.
; tvs,(phot/modelt)[k4:3*k4,k4:3*k4],mm=[0.7,1.2]*1.
; 2 options: model in convolved space
; deconvolve onto HST resolution -> make HST-IRAC color map.... -> strong regulate!!!
; reconvolve and show fit.....


function mophongo::dilate_segmap, seg, obj, ngrow
   compile_opt idl2, static

   logger, 'dilating segmap by ',ngrow,' pixels'

   ; find candidate grow pixels in segmentation map
   ; then assign the most frequent ID in their 3x3 neighborhood
   ; if equal -> coin flip (not implement, now taking median)
   kern=[[1,1,1],[1,1,1],[1,1,1]]
  ; seg = *self.segmap
   for i=0,ngrow -1 do begin
      bseg =  seg gt 0
      ipix = where(growmask(bseg,/inv) - bseg)           ; flag candidate grow pixels
      iloc = localindex(seg, kern, ipix=ipix)   ; get local neigborhood

      segloc = 1.0*seg[iloc]
      segloc[where(segloc eq 0)] = !values.f_nan         ; get median value... flawed
      newid = long(median(segloc,dim=1))

      seg[ipix] = newid ; assign the more frequent value
   end

   if arg_present(obj) then nobj = obj.length else nobj = 0

stop

   for i=0L, nobj-1 do begin
      o = obj[i]
      stop

      ii = *o.iseg
      ix = ii mod (o.dim)[0]
      iy = ii / (o.dim)[0]
      o.iso_area = pix.length   ; number of pixels
      o.xmin = ( min(ix) - o.buf ) > 0
      o.ymin = ( min(iy) - o.buf ) > 0
      o.xmax = ( max(ix) + o.buf ) < (o.dim[0]-1)
      o.ymax = ( max(iy) + o.buf ) < (o.dim[1]-1)
      obj[i] = o
    end

    return, seg
end


; this should go to separate class
;
;The Gaussian kernel (see equation 24) in the fixed-Gaussian polynomial
;centroiding is separable, and correlation of the kernel with an image
;of star can be performed exactly in no time. Therefore in terms of
;computational cost, this method is more efficient than the matched
;filter method in which the image of star is correlated with a PSF of
;arbitrary shape.
; return indices into src of all objects that overlap with list of id
function mophongo::overlap, src, ii, id=id, distance=distance, stopme=stopme

   if keyword_set(stopme) then stop

   if keyword_set(id) then ii = where_array([id], [src.id])
   if n_elements(ii) eq 0 then return, lindgen(src.length)

   ; catch double entries
   if n_elements(id) eq 1 and n_elements(ii) gt 1 then ii = ii[0]   ; catch double entries
   if n_elements(id) gt 0 and n_elements(ii) ne n_elements(id) then logger, 'Warning: duplicate id in source list'

   x = src.x
   y = src.y
   dim = [ 1#(src.xmax-src.xmin), 1#(src.xmax-src.xmin)]
   if keyword_set(distance) then d = distance[0]/2.0 else d = max(dim,dim=1)/2.0 - 1

   foreach j, ii do $
      inn = append(inn, where((x[j]-x)^2 + (y[j]-y)^2 lt (d[j<(d.length-1)]+d)^2, /null) )

   return, inn.uniq()
end

; MPFIT: Parameter values are passed in "p"
; assume psf model, shape is correct fit flux and shift
;function Mophongo::centroid_psf_fitting, p, X=x, Y=y, err=err, img=img
;   obs = self.shift(obs, p[0], p[1])
;   return, (obs - p[2]*model)
;end

; full fit not necessary... the centroiding mostly depends on the
function centroid_psf, p, err=err, model=model, obs=obs, mask=mask, stopme=stopme

   dim = obs.dim
   xout = indgen(dim[0])-p[0]
   yout =  indgen(dim[1])-p[1]

   mod_sh = interpolate(model, xout, yout, /GRID, missing=0.0, cubic=-0.5)

   if n_elements(p) gt 2 then res = (obs - p[2]*mod_sh)/err else res = (obs - mod_sh)/err

   res =  res[2:-3,2:-3]  ; trim edges

   if keyword_set(mask) then $
      res *= interpolate(byte(obs ne 0.0),  xout, yout, /GRID, missing=0.0) ne 0

   if keyword_set(stopme) then begin
      cgerase
      loadct,0
      tvs, res, mm=[-1,1]*5*stdev(res)
      tvs, obs, pos=1
      tvs, mod_sh, pos=2
      tvs, smooth(res,3), pos=3
      logger,'p:', p,  alog10(total(res^2))
   end

   return, reform(res, n_elements(res))
end

function add_model, p, err=err, residual=residual, model1=model1, model2=model2,  mask=mask, stopme=stopme
   dim = model1.dim

;  p = x2 y2 f2 f1
   xout = indgen(dim[0])-p[0]     ; position of model 2
   yout =  indgen(dim[1])-p[1]
   model2_sh = interpolate(model2, xout, yout, /GRID, missing=0.0)

   res = (residual - (p[3]*model1 + p[2]*model2_sh) )/err

   res = temporary(res[2:-3,2:-3])  ; trim edges

   if keyword_set(mask) then $
      res *= interpolate(byte(obs ne 0.0),  xout, yout, /GRID, missing=0.0) ne 0

   if keyword_set(stopme) then begin
      tvs, residual, fac=3
      tvs, res, fac=3,pos=1
      tvs, model1, fac=3,pos=2
      tvs, model2, fac=3,pos=3
   ;   [reform(model1,1,model1.length),reform(model2,1,model2.length)]
;      logger,'p:',p
;      stopkey
   end

   return, reform(res, n_elements(res))
end

function mophongo::shift, img, xshift, yshift, missing=missing
   if not keyword_set(missing) then missing = 0.0
   dim = img.dim
   return, interpolate(img, indgen(dim[0])-xshift, indgen(dim[1])-yshift, missing=missing, /GRID, cubic=-0.5)
end

pro testme, det
help, det
stop

end

; set up memory mapping in thread
; memseg/file = memory map name/file
; dim/type = properties of memory maps
; ksz = convolution kernel size
; fdetpsf, fkern = files with psf,kernel maps
pro mophongo::initialize_thread, memseg, memfile, memdim, memtype, fdetpsf, fkern, kdim
   compile_opt static

   psf = mophongo.getpsf(1,1,filename=fdetpsf)

   bin =  self.param.fit_bin
   extast, headfits(self.fdet), ast_det
   kern = mophongo.getkernel(1,1,filename=fkern, ast_out = bin eq 1 ? ast_det : !null)  ; @@@ fix kernel size

   s = {tmpl_source, inherits source, tmpl:fltarr(kdim) }

   ; remap memory segments in thread, special case for the model struct
   for i=0,memseg.length-1 do $
      shmmap, memseg[i], dim=memdim[*,i], type=memtype[i], template= memtype[i] eq 8 ? s : !null, $
              filename= memfile[i] ne 'none' ? memfile[i] : !null
   help,/shared
end

pro mophongo::thread_sync, thread, msg=msg
    compile_opt static

    if ~keyword_set(msg) then msg = ''

    status = lonarr(thread.length)
    busy = 1
    while busy do begin
        for j=0,thread.length-1 do status[j] = thread[j].status()
        busy = total(status eq 1)      ; if no active processes left, clean up
        statusline, ' ('+(long(busy)).tostring()+'/'+thread.length.tostring()+' threads) ' + msg
        wait, 0.25
    end
end
;        statusline, 'Threads: '+strjoin(strn(status),',')+' waiting for '+strn(long(busy))
;    if keyword_set(debug) then print, 'Threads synced.                '

; @@@ Optimizations: 1 only consider part of kernel for fainter sources
; @@@ cache kernels, psfs
; @@@ rebuild fconvolve with faster FFTs. only FFT if needed
; @@@ determine by scaling IRAC_PSF to source peak flux -> cut err_pix/5.
; @@@ detimage should be called template image
; @@@ should be able to give multiple template images

pro mophongo::make_tmpl_thread_old, index, memseg, fit_snrlo_psf
   compile_opt static

   bin = self.param.fit_bin
; @@@@ can not have any self...
   ; link memory maps
   for i=0,memseg.length-1 do !null = execute(memseg[i]+' = shmvar("'+memseg[i]+'")')

   ; render kernel and template on ast_tmpl resolution = bin * ast_det resolution
   extast, headfits(self.fdet), ast_tmpl
   ast_tmpl.cd *= bin
   kern = mophongo.getkernel(1, 1, ast_kern=ast_kern, ast_out=ast_tmpl)
   npix_kern = bin*bin/total(kern^2)
   ; @@@  size of kernel in det pixel units -> note this should be in photometry image units

   !null = growthcurve(self.getpsf(1,1),rhalf=rhalf_det)
   !null = HISTOGRAM(segmap,min=1,rev=ri)
   kgrow = apermask(oddsize(round(rhalf_det*2)))
   dim = det.dim

   logger, 'Creating templates ', /info
   for i=0,index.length-1 do begin
      j = index[i]
      s = obj[j]
      print, '.', format='($,a)'

      iseg = cgReverseIndices(ri, s.id-1)  ; @@@ this indexing is not robust

      ; @@@ should read this from internal templates? not the image maps....
      ; so we can deal transparently with any model (blender, sersic fits)
      det_img = det[s.xmin:s.xmax,s.ymin:s.ymax]
      seg = segmap[s.xmin:s.xmax,s.ymin:s.ymax]

      ; grow mask of object and neigbors, keep grown pixels dominated by object
      knn = convol(seg ne s.id and seg ne 0, kgrow)
      kseg = convol(seg eq s.id, kgrow)
      kseg = kseg gt knn and kseg ne 0

      det_ivar = mean(detwht[iseg])               ; detection ivar
      s.eflux_model = sqrt(npix_kern / mean(photwht[iseg]) )  ; model error

      psf = mophongo.getpsf(s.x,s.y)

      tsz = det_img.dim
      psz = psf.dim
      xpeak = s.ipeak mod dim[0] - s.xmin
      ypeak = s.ipeak/dim[0] - s.ymin

      ; SNR in tmpl image segment, reject segment pixels < 0 -> these will be replaced by PSF wings
      iseg = where(kseg and det_img gt 0, complement=inoseg,/null)
      f_tmpl = total(det_img[iseg])
      e_tmpl = sqrt(iseg.length/det_ivar)

      ; @@@ need to make sure this works also for small psfs...
      ; place psf tile at highest peak
      psf_tile = extrac(psf,psz[0]/2-xpeak,psz[1]/2-ypeak,tsz[0],tsz[1])

      ; at low snr add in point source prior to tmpl in quadrature
      ; if det_img a empty map, then result is a point source prior
      ; @@@ note we are ignoring sub-pixel here.... probably ok
      if f_tmpl/e_tmpl lt 1.5*fit_snrlo_psf then $
         det_img[iseg] = sqrt(det_img[iseg]^2 + (e_tmpl*fit_snrlo_psf*psf_tile[iseg])^2)

      ; add PSF wings outside the segmap, normalized to flux in segment
      det_img[inoseg] = psf_tile[inoseg]*total(det_img[iseg])/total(psf_tile[iseg])
      det_img /= total(det_img)

      ksz = kern.dim * bin     ; treat kernel coordinates in tmpl pixel coordinates
      kloc = ( ksz/2 - tsz/2 ) > 0

;print, s.id, s.x, s.y
;print, s.xmin,s.ymin
; 2         549         205       ll
; 2        14.6578      15.4557     rel
; 2       563.658      220.456     catalog
;         563.662      220.455      142.072  true
;print,s.x, s.y
;print,s.x-s.xmin, s.y-s.ymin
;tvs, det_img,mm=[-1,1]*0.5e-1
;!null =  gauss2dfit(det_img,a)

      det_tile = extrac(det_img, -kloc[0], -kloc[1], ksz[0], ksz[1])
      if bin gt 1 then det_tile = rbin(det_tile, bin)  ; bin down tmpl just before convolution: ok, center good

;!null =  gauss2dfit(det_tile,a)  ;     201.661      202.455    in tile
;t3 = rbin(det_tile,3)
;!null =  gauss2dfit(t3,a)        ;     66.8859      67.1540  in t3
;det_tile2 = congrid(t3,ksz[0],ksz[1],cubic=-0.5,/center)/9.0
;det_tile2 = congrid(t3,ksz[0],ksz[1],interp=1,/center)/9.0
;;det_tile2 = rebin(t3)  ; !no!
;det_tile2 = rbin(t3,3,/expand,interp=1)
;tvs, det_tile-det_tile2, mm=[-1,1]*1e-3
;tvs, det_tile2, mm=[-1,1]*1e-3
;!null =  gauss2dfit(det_tile2,a2)
; trutile: 201.661      202.455
; sample:  201.782      202.313
; linear:  201.723      202.381
; cubic:   201.730      202.37
; rebin:   200.723      201.381   ; !no!
; rbin:    201.723      202.38
; trutile: 201.661      202.455
; trueimg  563.662      220.455

;d3 = rbin(det,3)
;yfit = MPFIT2DPEAK(d3, g, /gauss,  ESTIMATES =[0,1,1,1,s.x/3,s.y/3,0])
;print,s.x, s.y

; 187.553      73.1537   - measured
; 563.662      220.455 true
; expect:
;  187.553      73.1519

      ; ast_tmpl takes care of pix scale / orientation
      kern = mophongo.getkernel(s.ra, s.dec, ast_out=ast_tmpl)
      s.tmpl = fconvolve(kern,det_tile)                        ; shift so ll pix divisible by bin
   ;   s.tmpl = shift(fconvolve(kern,det_tile), shx, shy)     ; shift so ll pix divisible by bin

; trutile: 201.661      202.455
; trueimg  563.662      220.455
!null =  gauss2dfit(kern,k)    ; 202.000      202.000  ok
!null =  gauss2dfit(s.tmpl,ak) ; 201.664      202.454  ok
; trutile: 201.661      202.455
; trueimg  563.662      220.455
print, s.xmin - kloc[0]   ;   362  + 201.664   = 563.664
print, s.ymin - kloc[1]   ;    18  + 202.454   = 220.454

      s.xmin -= kloc[0]
      s.ymin -= kloc[1]
      s.xmax = s.xmin + ksz[0] - 1L
      s.ymax = s.ymin + ksz[1] - 1L
      s.dim = s.tmpl.dim * bin
stop

      if keyword_set(stopme) then begin
         tvs, kseg, pos=0
         tvs,det_img, pos=1
         tvs, s.tmpl, pos=2
         print, s.id, s.x, s.y, bin
         stopkey
      end

      ; store results
      obj[j] = s
   end
end


pro mophongo::make_tmpl_thread, index, memseg, fit_snrlo_psf
  ; compile_opt static

; @@@@ should condense and contain all position / size based transformations to src[0]

; @@@ simplify initialization, check binning vs no binning
   bin = self.param.fit_bin
   binfast = self.param.fit_fast ; calculate everything in binned ?
   if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

   for i=0,memseg.length-1 do !null = execute(memseg[i]+' = shmvar("'+memseg[i]+'")')

   ; render kernel and template on ast_tmpl resolution = bin * ast_det resolution
   extast, headfits(self.fdet), ast_det
   extast, headfits(self.fdet), ast_tmpl
   ast_tmpl.cd *= bin

  ; note: kernel is pre-deconvolved for binning at scale bin, and interpolation (linear or cubic)
   kern = mophongo.getkernel(1, 1, ast_kern=ast_kern, ast_out=ast_tmpl)
   npix_kern = (ast_tmpl.cd[0]/ast_det.cd[0])^2/total(kern^2)

   gc = growthcurve(self.getpsf(1,1),rhalf=rhalf_det)
   h = HISTOGRAM(segmap,min=1,rev=ri)
   kgrow = apermask(oddsize(round(rhalf_det*2.0)))
   dim = det.dim
   fp=objects.flux_peak

; @@@ make sure it robustly determines where gc does not increase any more
   ftrunc = 1.0
   raper = range(2,202,30,/log)
   gckern= growthcurve( mophongo.getkernel(1, 1, ast_out=ast_tmpl), raper=raper)
   if ftrunc ge 1.00 then rlim = (objects[0].tmpl.dim)[0]*bin/2 $
      else rlim = interpol(raper, gckern, ftrunc < max(gckern))
   logger, 'truncating PSF to ftrunc=',ftrunc,' rlim = ',rlim

   logger, 'Creating templates ', /info
   for i=0,index.length-1 do begin
      j = index[i]
      s = objects[j]

    ;  iseg = cgReverseIndices(ri, s.id-1)  ; @@@ this indexing is not robust
       det_img = det[s.xmin:s.xmax,s.ymin:s.ymax]
       det_wht = detwht[s.xmin:s.xmax,s.ymin:s.ymax]
       phot_wht = photwht[s.xmin:s.xmax,s.ymin:s.ymax]
       seg = segmap[s.xmin:s.xmax,s.ymin:s.ymax]

      ; grow mask of object and neigbors, keep grown pixels dominated by object
      knn = convol(seg ne s.id and seg ne 0, kgrow)
      kseg = convol(seg eq s.id, kgrow)
      kseg = kseg gt knn and kseg ne 0
      iseg = where(kseg)  ; 1e-4

      det_ivar = mean(det_wht[iseg])               ; detection ivar
      s.eflux_model = sqrt(npix_kern / mean(phot_wht[iseg]) )  ; model error

      psf = mophongo.getpsf(s.x,s.y)   ; 1e-4

      hsz = det_img.dim
      psz = psf.dim
      xpeak = s.ipeak mod dim[0] - s.xmin
      ypeak = s.ipeak/dim[0] - s.ymin

      ; SNR in tmpl image segment, reject segment pixels < 0 -> these will be replaced by PSF wings
; issues with under splitting
; if s.parent_id ne 0 then stop
;if fp[j] gt 1e3 then stop

      iseg = where(kseg and det_img gt 0, complement=inoseg,/null)
      f_tmpl = total(det_img[iseg])
      e_tmpl = sqrt(iseg.length/det_ivar)

      ; @@@ need to make sure this works also for small psfs...
      ; place psf tile at highest peak
      psf_tile = extrac(psf,psz[0]/2-xpeak,psz[1]/2-ypeak,hsz[0],hsz[1])

      ; at low snr add in point source prior to tmpl in quadrature
      ; if det_img a empty map, then result is a point source prior
      ; @@@ note we are ignoring sub-pixel here.... probably ok
      if f_tmpl/e_tmpl lt 1.5*fit_snrlo_psf then $
         det_img[iseg] = sqrt(det_img[iseg]^2 + (e_tmpl*fit_snrlo_psf*psf_tile[iseg])^2)

      ; add PSF wings outside the segmap, normalized to flux in segment
      det_img[inoseg] = psf_tile[inoseg]*total(det_img[iseg])/total(psf_tile[iseg])
      det_img /= total(det_img)

      tsz = (s.tmpl.dim)[0]*bin

      if 0 then begin ; first convolve then bin
         ; kernel size in det coordinates -> lets truncate
         ; check if this works when det_img is > kernel size
         dsz = round(2*rlim+1)
         dloc = ( dsz/2 - hsz/2 ) > 0
         det_tile = extrac(det_img, -dloc[0], -dloc[1], dsz, dsz)
         kern = mophongo.getkernel(s.ra, s.dec, ast_out=ast_tmpl)
         kloc = dsz/2 - kern.dim/2
         kern_tile  = extrac(kern, -kloc[0], -kloc[1], dsz, dsz)
         ss = fconvolve(kern_tile,det_tile, pad=0)
         tloc =  tsz/2 - dsz/2
         s.tmpl =  rbin(extrac(ss, -tloc, -tloc, tsz, tsz),3)
         s.xmin -= (dloc + tloc)[0]
         s.ymin -= (dloc + tloc)[1]
      end else begin    ; first bin then convolve
         kloc = ( tsz/2 - hsz/2 ) > 0
         s.xmin -= kloc[0]
         s.ymin -= kloc[1]
         offx = (s.xmin - 1) mod bin
         offy = (s.ymin - 1) mod bin
         oxymin = [s.xmin,s.ymin]
         s.xmin -= offx      ;image so that xmin and ymin to be divisible by bin
         s.ymin -= offy       ; this aligns all binned patches to the same binned grid
; @@ if we are summing in binned coordinates, no extra smoothing -> so presmooth heren
; note @@ if we are doing any extra interpolation (e.g. shifting) then those convolutions need to be taken into account
       det_img = smooth(det_img,3)
  ;      if binfast then det_img = rbin(rbin(det_img,3), 3, /expand, cubic=cubic, interp=interp)
         det_tile = extrac(det_img, -kloc[0]-offx, -kloc[1]-offy, tsz, tsz)
         ; check shift here   ; all ok!
;         junk = gauss2dfit(det_tile,g)
;         print, 'template: ', g[4]+s.xmin, g[5]+s.ymin
;         print, 'expected: ',s.x,s.y
;         print, 'coordinate of x,y min', s.xmin, s.ymin, ' binned by ',bin, ' ',(s.xmin-1.0)/bin,(s.ymin-1.0)/bin
         if bin gt 1 then det_tile = rbin(det_tile,3)
         kern = mophongo.getkernel(s.ra, s.dec, ast_out=ast_tmpl)
         s.tmpl = fconvolve(kern, det_tile, pad=0)
;         tvs,center(kern,/ch)
;         tvs,center(s.tmpl,/ch)    ; ok!
;         tvs,center(det_tile,/ch)
;         print, (s.x - s.xmin - 1.0)/bin, (s.y - s.ymin - 1.0)/bin    ; ok ! from original to binned patch
     end

      s.xmax = s.xmin + tsz - 1L
      s.ymax = s.ymin + tsz - 1L
      s.dim = s.tmpl.dim * bin

      ; store results
      objects[j] = s
      statusline, 'generating templates '+i.tostring()+'/'+(index.length).tostring()
   end
end

; coordinates in 0-based system to binned coordinates
;  x_os = (x + 0.5)*os - 0.5
;  x = (x_os + 0.5)/os - 0.5
   ; binned coordinates


;gf = gauss2dfit(kern,g) & print,g
;gf = gauss2dfit(gg,g) & print,g
;det_img = gauss_smooth(odet_img, presmooth_gauss*bin, width=round(oddsize(presmooth_gauss*3.0*bin*2+1)) < (min(tsz)-2),/edge_trunc)
;!null = gauss2dfit(s.tmpl,a)
;print, a[4:5] + [s.xmin,s.ymin]
;print, a[4:5] + ([s.xmin,s.ymin]*1.0)/bin
;print, (s.x-1.0)/bin, (s.y-1.0)/bin, ' expected '
;print, (a[4:5] + [s.xmin,s.ymin]-1)/3.
;print, (s.x-1.0)/3, (s.y-1.0)/3, ' expected3 '
;print, (s.xmin-1.)/bin, (s.ymin-1.)/bin
;print, 'shifted by ',shx,shy
;stopkey
;   if bin gt 1 then begin
;;      kb = rbin([[0,0,0,0,0],[0,0,1d,0,0],[0,0,0,0,0]],bin,/expand)
; ;     kb = rbin([[0,0,0,0,0],[0,0,1d,0,0],[0,0,0,0,0]],bin,/expand)
;  kb= dblarr(31,31) & kb[15,15]= 1
;      kbf =   fft(kb)
;      kbinv =  real_part(fft((abs(kbf) gt 1d-10)/(kbf + (kbf eq 0)),/inverse))/kbf.length
;   end;

;stop

; trutile: 201.661      202.455
; trueimg  563.662      220.455
;!null =  gauss2dfit(kern,k)    ; 202.000      202.000  ok
;!null =  gauss2dfit(s.tmpl,ak) ; 201.664      202.454  ok
; trutile: 201.661      202.455
; trueimg  563.662      220.455
;print, s.xmin - kloc[0]   ;   362  + 201.664   = 563.664
;print, s.ymin - kloc[1]   ;    18  + 202.454   = 220.454

;print, s.id, s.x, s.y
;print, s.xmin,s.ymin
; 2         549         205       ll
; 2        14.6578      15.4557     rel
; 2       563.658      220.456     catalog
;         563.662      220.455      142.072  true
;print,s.x, s.y
;print,s.x-s.xmin, s.y-s.ymin
;tvs, det_img,mm=[-1,1]*0.5e-1
;!null =  gauss2dfit(det_img,a)
;!null =  gauss2dfit(t3,a)        ;     66.8859      67.1540  in t3  (x-1)/3. !!
;t3 = rbin(det_tile,3)
;!null =  gauss2dfit(t3,a)        ;     66.8859      67.1540  in t3
;det_tile2 = congrid(t3,ksz[0],ksz[1],cubic=-0.5,/center)/9.0
;det_tile2 = congrid(t3,ksz[0],ksz[1],interp=1,/center)/9.0
;;det_tile2 = rebin(t3)  ; !no!
;det_tile2 = rbin(t3,3,/expand,interp=1)
;tvs, det_tile-det_tile2, mm=[-1,1]*1e-3
;tvs, det_tile2, mm=[-1,1]*1e-3
;!null =  gauss2dfit(det_tile2,a2)
; trutile: 201.661      202.455
; sample:  201.782      202.313
; linear:  201.723      202.381
; cubic:   201.730      202.37
; rebin:   200.723      201.381   ; !no!
; rbin:    201.723      202.38
; trutile: 201.661      202.455
; trueimg  563.662      220.455

; @@@@ should use even binning, defined on half pixels ?
; double check that FFTs do not introduce offsets
;
pro explore_binning

if 0 and s.id ge 580 and (s.id eq 22 or s.flux_peak gt 3) then begin
 ;  ii = match_2d([2511.397], [1126.006], objects.x,objects.y, 50, mat=di)
 ;  s=objects[ii]
   window, xs=1200, ys=300
   p=(*self.photimg)[s.xmin:s.xmax,s.ymin:s.ymax]
   d=(*self.detimg)[s.xmin:s.xmax,s.ymin:s.ymax]
   tvs,center(d[164:240,164:240],/ch) ,fac=100
   print,'center hi obs ', s.x,s.y

   tip = rbin(s.tmpl,3,/expand, cubic=-0.5)
   tvs,tip[164:240,164:240] ,pos=1
   a=center(tip,/ch)
   a=mpfit2dpeak(tip,gtmpl)
   print, 'width tmpl ', gtmpl[2:3]*2.355

   tvs,center(p[164:240,164:240],/ch),pos=2
   a=mpfit2dpeak(p[164:240,164:240],g)
   print, 'width obs ', g[2:3]*2.355
   print, 'center obs ',g[4:5]

   ;tip = rbin(s.tmpl,3,/expand, interp=1)
   ;a=mpfit2dpeak(tip,g)
   ;print, g[2:3]*2.355

   scl = max(p[164:240,164:240])/gtmpl[1]
   tvs, (p-tip*scl)[164:240,164:240], pos=3

; restore,'gauss_sim3.sav'

  stopkey
end

if 0 then begin

; when padding kept to minimum
; note: screen for underflow threshold or FFT x3 slower
;      fsh =  dsz/2 +  dsz mod 2
;   kern_ft = (fft(kern)
;   det_ft = fft(det_tile)
;
;      conv =    shift(fft(fft(kern)*fft(det_tile),/inverse), fsh, fsh)
;      s.tmpl =   rbin(float(conv),bin)*kern.length

   ; s.tmpl = fconvolve(kern,det_tile)
   ; print,fast_factor(tsz[1])
   a = fconvolve(kern,det_tile)
   a = fft(kern)

   b = convol_fft(det_tile, kern, /no_padding)
   c= convolve(kern,det_tile, /no_pad)
   d =  rebin(convol_fft(kern,det_tile,/no_padding),bin)
   timeit, 'a = fconvolve(kern,det_tile, pad=0)
   timeit, 'b = convol_fft(det_tile, kern, /no_padding)
   timeit, 'c= convolve(kern,det_tile, /no_pad)
   timeit, 'd =  rebin(convol_fft(kern,det_tile,/no_padding),bin)

   tvs, b, mm=[-1,1]*1e-5

   ; psm = sqrt((presmooth_gauss*bin)^2-1.0)
   model = fconvolve(rbin(kern,3,/exp,cubic=-0.5),det_img)


   gfm = gauss2dfit(model,gm) & print,gm
   print, gm[2:3]*2.355

   psfg = gauss_smooth(psf, sqrt((presmooth_gauss*bin)^2-(fwhm_bin)^2), width=round(oddsize(presmooth_gauss*3*bin*2+1)) < (min(tsz/2)-2), /edge_trunc)
   modelb = imshift(rbin(fconvolve(kern,rbin(psfg,3)),3,/exp,cubic=-0.5),gm[4:5]-202,cubic=-0.5)
   gfb = gauss2dfit(modelb,gmb) & print,gmb
   print, gmb[2:3]*2.355

   dd = (*self.detimg)[s.xmin:s.xmax,s.ymin:s.ymax]
   ddsm = gauss_smooth(dd, sqrt((presmooth_gauss*bin)^2-(fwhm_bin)^2), /edge_trunc)
   det3 = rbin(ddsm,bin)
   pphot =  (*self.photimg)[s.xmin:s.xmax,s.ymin:s.ymax]
    stop
   tvs, pphot, mm=[-1,1]*1e-3
   tvs, pphot-model*57.7, mm=[-1,1]*5e-4
   tvs, pphot-modelb*57.95, mm=[-1,1]*5e-4
   tvs, det3, mm=[-1,1]*1e0

   tvs, det_img,mm=[-1,1]*1e-4
   gfn = gauss2dfit(det_img,gn) & print,gn
   print, gn[2:3]*2.355
   gfk = gauss2dfit(kern,gk) & print,gk
   print, gk[2:3]*2.355
   gfp = gauss2dfit(phot,gp) & print,gp
   print, gp[2:3]*2.355
   gfd3 = gauss2dfit(det3,gd3) & print,gd3
   print, gd3[2:3]*2.355

   stop
end
; 19 57.7
; 22 2.
; 34 142


      if bin then begin

; note: convolve x bin  != bin x convolve
; because bin x convolve = binning convolution on both model and kernel
         extast, headfits(self.fdet), ast_det
         okern = mophongo.getkernel(s.ra, s.dec, ast_out=ast_det)
         otmp = fconvolve(okern, det_tile )         ;  origonal res
         btmp = fconvolve(kern,rbin(det_tile,bin))  ;  binned res

         ; to mitigate binning effects on high res image, convolve core at original resolution
         tmp = fconvolve(kern,rbin(det_tile,bin))
         bsz = dsz/bin
         dc =  extrac(det_tile,dsz/2-bsz/2,dsz/2-bsz/2,bsz,bsz)
         csz = bsz/bin
         kcc = extrac(kern,bsz/2-csz/2,bsz/2-csz/2,csz,csz)
         kc = congrid(kcc/bin^2, bsz, bsz, cubic=-0.5, /center)
         tmpc =   ( rbin(fconvolve(kc,dc), 3) )[1:-2,1:-2]    ; drop edges
         cloc = ( bsz/2 - (csz/2-1)) > 0
         tmp[cloc:cloc+(csz-2)-1,cloc:cloc+(csz-2)-1] = tmpc

         tvs, rbin(otmp,3) - btmp, pos=0,mm=[-1,1]*1e-6                 ; binned original
         tvs, rbin(otmp,3) - tmp, pos=1,mm=[-1,1]*1e-6                  ; binned original os core
         ;tvs, rbin(otmp,3) - tmp, pos=2,mm=[-1,1]*1e-6 ; binned oversampled core
         tvs,  otmp - rbin(btmp,/expand,3, cubic=-0.5),pos=3,mm=[-1,1]*1e-6    ; oversampled binned
         tvs,  otmp - rbin(tmp,/expand,3, cubic=-0.5), pos=4, mm=[-1,1]*1e-6   ; oversampled  binned, oversampled core
         tvs,  otmp - rbin(rbin(otmp,3),/expand,3, cubic=-0.5), pos=5, mm=[-1,1]*1e-6 ; origonal, binned, oversampled
         tvs,  otmp - smooth(otmp,3), pos=6, mm=[-1,1]*1e-6 ; origonal, binned, oversampled

         tvs,  otmp - rbin(btmp,/expand,3, cubic=-0.5),pos=0,mm=[-1,1]*1e-6   ; oversampled binned
         tvs,  smooth(otmp,3) - rbin(btmp,/expand,3, cubic=-0.5),pos=1,mm=[-1,1]*1e-6    ; oversampled binned
         tvs,  otmp - rbin(btmp,/expand,3, /interp),pos=2,mm=[-1,1]*1e-6   ; oversampled binned
         tvs,  smooth(otmp,3) - rbin(btmp,/expand,3, /interp),pos=3,mm=[-1,1]*1e-6    ; oversampled binned

         k = kern*0d
         k[66:68,66:68]=1.0
         ftk = fft(k,/center)
         tvs, ftk, mm=[-1,1]*1e-5
         t = shift(real_part(fft(fft(psf_gaussian(npix=135,fwhm=14),/center)/ftk, /inverse)),67,67)
         t=t/total(t)
         tvs,t,mm=[-1,1]*1e-2

         p=psf_gaussian(npix=135,fwhm=14,/double,/norm)
         im = real_part(fft(p,/center)/ftk)
         tvs, im, mm=[-1,1]*1e-4
         tvs, p, mm=[-1,1]*1e-4
         tvs, smooth(im,3,/nan), mm=[-1,1]*1e-4
         tvs,  otmp - smooth(otmp,3), pos=6, mm=[-1,1]*1e-6 ; origonal, binned, oversampled

         ;print,max(otmp)/minmax(rbin(otmp,3) - tmp)
         ;print,max(rbin(otmp,3))/minmax(rbin(otmp,3) - btmp)

      end else s.tmpl = fconvolve(kern,det_tile)


if 0 then begin
   extast, headfits(self.fdet), ast_det
   p = self.getpsf(1,1)
   k = self.getkernel(1,1,ast_out=ast_det)
   bin=3
   cb = rbin(fconvolve(k,p),3)
   bc = fconvolve(rbin(k,3),rbin(p,3))
   kszb = dsz/bin
   psz = (p.dim)[0]
   kc = extrac(k,dsz/2-kszb/2,dsz/2-kszb/2,kszb,kszb)
   pc = extrac(p,psz/2-kszb/2,psz/2-kszb/2,kszb,kszb)
   bcc = rbin(fconvolve(kc,pc),3)
   cbc = bc
   kszbb = kszb/3-2
   cbc[kszb/2-kszbb/2:kszb/2+kszbb/2,kszb/2-kszbb/2:kszb/2+kszbb/2] = bcc[1:-2,1:-2]
   tvs,cb-bc,mm=[-1,1]*1e-6
   tvs,cb-cbc,mm=[-1,1]*1e-6
end


p1 = psf_gaussian(npix=N,fwhm=3.0,/double,/norm)
p2 =  psf_gaussian(npix=N,fwhm=12.,/double,/norm)


; linear deconvolution gaussian -> matrix fails
;f=fltarr(31,31)
N = 151
p1 = psf_gaussian(npix=N,fwhm=3.0,/double,/norm)
p2 =  psf_gaussian(npix=N,fwhm=12.,/double,/norm)
npix = p1.length

pu = python.import('photutils')
win=pu.TukeyWindow(alpha=0.01)
kern = pu.create_matching_kernel(p2, p1, window=win)
pp=convolve(p2,kern)
ppc = extrac(pp,n/2-10,n/2-10,21,21)
ppc=ppc/total(ppc)
tvs, kern
tvs, ppc,mm=[-1,1]*1e-2
tvs, ppc-psf_gaussian(npix=19,fwhm=3.0,/double,/norm),mm=[-1,1]*1e-2
tvs, psf_gaussian(npix=19,fwhm=3.0,/double,/norm),mm=[-1,1]*1e-3

!null = gauss2dfit( ppc,g)


aa = dblarr(npix,npix)
;p[N/2-1:N/2+1,N/2-1:N/2+1] = 1.0
p2s = shift(p2,-15,-15)
for i=1,p1.length-1 do aa[i,*] = shift(p2s ,i)

alpha = 0.1
R = extrac(identity(npix),0,0,npix+2,npix)
l = [1,-2,1]
foreach i, where(R) do R[i] *= l

at = transpose(aa)
ata = aa # at +  alpha*(transpose(R) # R)    ; normal eq + regul
atainv = invert(ata)

atb = at ## reform(p1,p1.length)
 ; solution
xx = atainv ## atb

;pinv = shift(reform(xx,n,n),(n-1)/2,(n-1)/2)
pinv =  reform(xx,n,n)
pp=convolve(p2,pinv)

tvs, p1,mm=[-1,1]*1e-3
tvs, p2,mm=[-1,1]*1e-3
tvs, pp,mm=[-1,1]*1e-3

;y = fltarr(p.length)
;tvs, invert(aa)

;ata = b.T() # b
;finv= invert(ata + identity(961)),mm=[-1,1]*1e1
print, (invert(ata + identity(961)))
aainvr = (invert(ata + identity(961)))
stop
aay = aatwwp
;aainv =


end
; extast, headfits(self.fdet), ast_det
; kk = mophongo.getkernel(s.ra, s.dec, ast_out=ast_det)
; t = fconvolve(kk,det_img)

; tt = rbin(s.tmpl, /expand, self.bin, cub=-0.5)
; tvs, t-tt,mm=[-1,1]*1e-5
; if self.bin gt 1 then stopkey

;      mkgrid,b1.dim, xx,yy,c=[0,0]
;      b1b = rbin(b1,3,/expand,outdim=sz,cubic=-0.5)
;      b1b = rbin(b1,3,/expand,outdim=sz,/interp)
;      b1b = rbin(b1,3,/expand,outdim=sz)
;      tvs,b1b-ddet,mm=[-1,1]*1e-4

;@@@ rbin and expand works very well + vetted
;ddet = det_img[0:tsz[0]-2,0:tsz[1]-2]
;sz = size(ddet,/dim)
;b1 = rbin(ddet,3)
;b1b = rbin(b1,3,/expand,outdim=sz,cubic=-0.5)
;b1b = rbin(b1,3,/expand,outdim=sz,/interp)
;b1b = rbin(b1,3,/expand,outdim=sz)
;tvs,b1b-ddet,mm=[-1,1]*1e-4


; multithreaded function to convolve templates
; index = list sources to process
; fit_snrlo_psf = snr threshold for point source prior
function mophongo::make_tmpl, src, id=id, distance=distance
   compile_opt idl2

   if (src.ra)[0] eq 0.0 then begin
      xyad, headfits(self.fdet), src.x, src.y, ra, dec
      src.ra = ra
      src.dec = dec
   end
   bin = self.param.fit_bin

   ; get expected template size
   extast, headfits(self.fdet), atmpl
   atmpl.cd *=  bin
   kern = self.getkernel(median(src.ra),median(src.dec), ast_out=atmpl)

   ; get list overlapping sources within size(kernel) distance
   inn = self.overlap(src, index, id=id, distance=max(kern.dim*bin))
   logger, 'processing ', inn.length, ' sources, including neighbors'
   src = src[inn]

   ; create source info into new structure including a template image
   tmpl_src = {atmpl_source, inherits source, tmpl:fltarr(kern.dim), bin: bin}

   ; shared memory map, resuse if exists, optionally dump to disk
   map_exist = execute("a=shmvar('objects')",1,1)
   if map_exist then tmpl_src = shmvar('objects') else $
      tmpl_src = self.memmap(tmpl_src, dim=src.length, name='objects', file=self.param.fit_memmap)
   copy_struct, src, tmpl_src, NT_copied

  ; start threads, transfer memory mapping
  index = lindgen(src.length)

  npfft = python.import('numpy.fft')

  if index.length gt 12000 then begin
     thread = objarr(!cpu.hw_ncpu/2)
     for i=0,thread.length-1 do begin
       logger, 'starting thread ', i+1, /info
       thread[i] = obj_new('IDL_IDLBridge',output='')
       thread[i].setvar, 'memseg', *self.memseg
       thread[i].setvar, 'memfile', *self.memfile
       thread[i].setvar, 'memdim', *self.memdim
       thread[i].setvar, 'memtype', *self.memtype
       thread[i].setvar, 'fdetpsf', cwd()+self.fdetpsf
       thread[i].setvar, 'fkern', cwd()+self.fkern
       thread[i].setvar, 'kdim', kern.dim
       thread[i].execute,'mophongo.initialize_thread, memseg, memfile, memdim, memtype, '+$
                         'fdetpsf, fkern, kdim'
       thread[i].setvar, 'index', index[i:*:thread.length]
       thread[i].execute,'mophongo.make_tmpl_thread, index, memseg, '+self.param.fit_snrlo_psf.tostring(), /nowait
      end

      mophongo.thread_sync, thread, msg='Creating templates     '
   end else self.make_tmpl_thread, index, *self.memseg , self.param.fit_snrlo_psf

; 1 core: 1000/28.0, 8750/327
; 4 cores: 8750 215 startup  175 net

   return, tmpl_src
end

;      ptic
;      for i=0,thread.length-1 do begin  &$
;         thread[i].setvar, 'index', index[i:*:thread.length]  &$
;         thread[i].execute,'mophongo.make_tmpl_thread, index, memseg, '+self.param.fit_snrlo_psf.tostring(), /nowait  &$
;      end
;      mophongo.thread_sync, thread, msg='Creating templates     '
;      ptoc
;
 ;           scl=err_pix
 ;           !p.multi=[0,3,2]
 ;           detect_showstamp,s
 ;           cgimage, phot,  /stretch, minv=-scl,maxv=scl, layout=[3,2,4],/keep
 ;           cgimage, aa,  /stretch, minv=min(aa),maxv=max(aa), layout=[3,2,5],/keep
 ;           cgimage, phot-flux[0]*aa,  /stretch, minv=-scl,maxv=scl, layout=[3,2,6],/keep
 ;     ;      cgimage, phot-shift(flux*aa,-1,-1),  /stretch, minv=-scl,maxv=scl, layout=[3,2,6],/keep
            ; @@@ optimizations: 1 only consider part of kernel for fainter sources
            ; cache kernels, psfs
            ; rebuild fconvolve with faster FFTs. only FFT if needed
            ; determine by scaling IRAC_PSF to source peak flux -> cut err_pix/5.
  ;          tvs, tmplc*flux[0]
  ;          phot_psf = fconvolve(kern,psf)
  ;          tvs, aa*flux[0] gt err_pix/5., pos=1
  ;          gc = growthcurve(phot_psf,raper=raper)
  ;          plot, raper, gc
  ;          r90 = interpol(raper,gc,0.9)
  ;    end

   ;   logger, j, ' SNR(tmpl,seg) = ',f_tmpl/e_tmpl
; convolution can be up by ~ > 100 x
; PSF/kern retrieval by # galaxies / grid cel, so at least > 10
; @@@ test centering w/bright pixel
; this is very slow... can optimize:
; - work in reduced resolution (e.g. binned to phot_psf_fwhm/5.0 -> x10 speed up for a 3x binning)
;   or bin to ~0.5 x phot pixel scale ~ 0.15
;   round((0.3/2.)/0.06) ->
; - buffer FFT PSF -> x2-3
; - analyse size of PSF brightess expected brightess of scaled PSF -> clip wings
;   e.g. central r<100 (19% of area) contain 95% of flux, versus full 405 x 405 stamp
;   -> 5x speed up for faint sources (e.g. for SNR < 10)
; @@ could calculate dynamically based on growthcurve, by requiring 1-phi(r<R) < fac/SNR(r<R)
; where fac = 0.3
; so for SNR < 10 we'd discard < 5% of wings, and for SNR < 5 would be < 10%
; note: this flux is not "lost" we correct for it in any aperture corrections
; cap at a lower bound of SNR > 2.0 ; where it is a 30x speedup at the 15% clipping of wings

; memory map timing for
;% Time elapsed:        30.581898
;name                    time           count
;FFT                    19.185712    3093
;MOPHONGO::GETKERNEL     6.274919    1031
;INTERPOLATE             5.606644    6186
;MOPHONGO::MEMMAP        1.743389       1
;FREE_LUN                1.741106       1
;MOPHONGO::GETPSF        0.531163    1031

;% Time elapsed:        26.430065
;name                    time           count
;FFT                    18.722429    3093
;MOPHONGO::GETKERNEL     5.844073    1031
;INTERPOLATE             5.185095    6186
;MOPHONGO::GETPSF        0.518946    1031
;CONJ                    0.203823    1031
;TOTAL                   0.152116    8248

  ;  Loc = ( sc - sp/2 ) > 0         ;center PSF in new array,
   ;             s = (sp/2 - sc) > 0        ;handle all cases: smaller or bigger
   ;             L = (s + sim-1) < (sp-1)
   ;             psf_FT = conj(image)*0 ;initialise with correct size+type according
   ;             ;to logic of conj and set values to 0 (type of psf_FT is conserved)
   ;             psf_FT[ Loc[1], Loc[2] ] = psf[ s[1]:L[1], s[2]:L[2] ]
;AA = at ## a
;atb = at ## reform(1,phot,phot.length)
;flux = invert(AA)*atb

;timeit,'flux = invert(AA)*atb'
;timeit,'flux = invert(at ## a)'
;timeit,'c = at ## b'  ; very slow if b not (1,length)!!!!
;timeit,'flux = invert(at ## a) ## (at ## b)'
;timeit, 'c=reform(phot,phot.length)'
;timeit,'c = at ## a' ; fastest
;timeit,'c=matrix_multiply(a,at)'
;timeit, 'c=total(a*a)'  ; slowest
;report_memory
;h = hash()
;for i=0,1e4 do h[src[bs(8e3,len=1)].id] = fltarr(200,200)+i
;report_memory


; keep wcs map definition
; but never reconstruct on the fly for the full grid

function mophongo::getpsf_irac, ra, dec, filename=filename, pa=pa, display=display, pixscl=pixscl, tsz=tsz, fast=fast, overlap=overlap
   common mophongo_aor_com, mpsf, hpsf, map, hmap, current_psf, center_box
   compile_opt static

   logger, 'reconstructing IRAC PSF ',/info

   if not keyword_set(pa) then pa = 0.0

   if ~isa(mpsf) and ~isa(map) or isa(filename) then if ~filename.equals(kernel_file) then begin
      logger,'getpsf_aor --> restoring ',filename, /info
      mpsf = readfits(filename, hpsf, exten=1,/silent)   ; template
      map = readfits(filename, hmap, exten=2, /silent)   ; map
      current_psf = filename
      center_box = (mpsf.dim)[0]/15.0     ; PSFs are large... so use small box for centering
   end

   szpsf = size(mpsf,/dim)
   sz = size(map,/dim)
   len = sz[3]
   xy0 = (szpsf-1)/2.
   mkgrid, szpsf, d=d
   rscl = 1.0

   if ~keyword_set(tsz) then tsz = oddsize(szpsf[0],div=3)

   ; @@@ warning... does not catch if PSF is downsampled... we are always assuming r > 0
   ; can inflate array to full size now and do reconstruction heavily oversampled
   ; or do reconstruction on original pixel scale and then inflate
   if not keyword_set(fast) then if keyword_set(pixscl) then if abs(pixscale(hpsf)/pixscl-1) gt 1e-3 then begin
      rscl = pixscale(hpsf)/pixscl
      tsz = oddsize(round(rscl*szpsf[0]),div=3)
   end

  if keyword_set(ra) and keyword_set(dec) then begin
     ; @@@ need to catch out of bounds request and decide what to do with them
     adxy, hmap, ra[*], dec[*], x, y          ; use extension WCS header for map
     ix = round(x)                            ; note: the grid has same coord system as 0-based "pixels"
     iy = round(y)                            ; so lower-left corner of pixel is -0.5,-0.5
  end else begin
     mkgrid, (map.dim)[0:1], ix, iy, c=[0,0]
     xyad, hmap, ix, iy, ra, dec          ; use extension WCS header for map
     if keyword_set(overlap) then begin
       oxmax = sxpar(overlap,'NAXIS1')
       oymax = sxpar(overlap,'NAXIS2')
       adxy, overlap, ra, dec, ox, oy
       iok = where(ox gt 0 and ox lt oxmax-1 and oy gt 0 and oy lt oymax-1, nok)
       if nok eq 0 then return, !null
       ix = long(ix[iok])
       iy = long(iy[iok])
       ra = ra[iok]
       dec = dec[iok]
       logger, 'keeping ',nok, ' PSF grid points overlapping '
     end
  end

; 0.06405 per PSF

   ; check if any weights are nonzero, if not return
   for j=0,ix.length-1 do totw = (isa(totw) ? totw : 0.0) + total(map[ix[j],iy[j],0,*])
   if totw eq 0 then return, !null

; should just render them and interpolate psf, rather than rebuild? grid is 24" grid.
; yes. then we have same interface for both kernel and IRAC PSF

   gpsf = extrac(mpsf,0,0,tsz,tsz)
   gpsf =  warp_image(gpsf, 0., rscl, xy0[0], xy0[1], cubic=-0.5, missing=0.0)
;   gpsf = center(warp_image(gpsf, 0., rscl, xy0[0], xy0[1], cubic=-0.5, missing=0.0),fwhm=center_box*rscl,/check,missing=0.0)
   m=apermask(gpsf.dim,(gpsf.dim)/2.0,d=d)
   gpsf = gpsf*m/total(gpsf*m)
   psf = fltarr([gpsf.dim,ix.length])

   if not gpsf.isfinite() then logger, 'PSF contains NaNs!', /critical

   aor_pa_old=0.0

   for j=0,ix.length-1 do begin
      tmp = fltarr(gpsf.dim)

      for i=0,len-1 do begin
       ; wh = im_hist1d(a, w, binsize=2, obin=xh)    wh = im_hist1d(a, binsize=2, obin=xh)
       ; condense into weighted histogram ?  Result = HIST1D( Array , Weight, bin=2)

        aor_w = map[ix[j],iy[j],0,i]     ;
        aor_pa = map[ix[j],iy[j],1,i]    ;
        if aor_w[0] le 0 then continue   ; skip if no weight

        tmp += warp_image(gpsf, aor_pa + pa, 1.0, (tsz-1.0)/2.0, (tsz-1.0)/2.0, cubic=-0.5, missing=0.0)*aor_w

        if keyword_set(display) then begin
           print, i+1, aor_w, aor_pa, format='(i,3f)'
           tvs, rot(gpsf,-aor_pa-pa, 1.0, (tsz-1.0)/2.0, (tsz-1.0)/2.0, cubic=-0.5,missing=0.0), fac=8, pos=0
           tvs, warp_image(gpsf, aor_pa+pa, 1.0, (tsz-1.0)/2.0, (tsz-1.0)/2.0, cubic=-0.5, missing=0.0)*aor_w,fac=8,pos=1
           tvs, tmp, fac=10, pos=2
           aor_pa_old = aor_pa
        end
     end
     psf[*,*,j] = tmp
     statusline, 'Loading IRAC PSF '+nsig(ix[j])+' '+nsig(iy[j])
  end

 ; @@@@
 ; or do reconstruction on original pixel scale and then inflate
 ; if very well sampled, then outcome is the same
   if keyword_set(fast) then if keyword_set(pixscl) then if abs(pixscale(hpsf)/pixscl-1) gt 1e-3 then begin
      rscl = pixscale(hpsf)/pixscl
      tsz = oddsize(round(rscl*szpsf[0]),div=3)
      opsf = psf
      psf = fltarr([tsz,tsz,ix.length])
      ; center upon magnifying... somehow here the largest fractional offsets are seen....
      for j=0,ix.length-1 do $
         psf[*,*,j] =  warp_image(extrac(opsf[*,*,j],0,0,tsz,tsz), 0.0, rscl, xy0[0], xy0[1], cubic=-0.5, missing=0.0) / rscl^2
   end

   if keyword_set(display) then print, ra,dec, rscl, total(psf)
   return, psf
end
;         psf[*,*,j] = center(warp_image(extrac(opsf[*,*,j],0,0,tsz,tsz), 0.0, rscl, xy0[0], xy0[1], $
;                     cubic=-0.5, missing=0.0) / rscl^2, /check, fwhm=center_box*rscl, missing=0.)


; in principle only this, when running the catalog
; interpolated kern on grid, hardcoded on some xy kernel
; only supply x,y if you certain pixel scale and logical coordinates are the same
; @@@@ this needs to be simplified
; @@@@ e.g. by supplying instead location and desired pixscale and PA
; @@@@ put in structure including ra, dec, PA, pixscale (timeit, but shouldnt be slower)
; kern.img kern.ra, kern.dec kern
function mophongo::getkernel, ra, dec, filename=filename, cubic=cubic, x=x, y=y, $
                      ast_out=ast_out, ast_kern=ast_kern, getbasis=getbasis, $
                      gaussian=gaussian, bin=bin
   common mophongo_kernel_com, basis, coef, ast, gra, gdec, gx, gy, xc, yc, kernel, fkernel, kern_bin
   compile_opt static
   underflow_threshold = 1e-10

   ; load new kernel if requested
   if ~isa(kern) and (isa(filename) ? ~filename.equals(fkernel) : 0) then begin
      restore, filename           ; gra, gdec, hkern, basis, coef
      fkernel = filename
      ; assumes that grid is rectilinear with axis aligned with the PA of the basis functions
      ; rectilinear is saved as 2D, irregular list as 1D
      basis = kernel.basis
      coef = kernel.coef
      extast, hkern, ast
      ad2xy, gra, gdec, ast, gx, gy
      getrot, ast, pa, cdelt
      dim = long([sqrt((basis.dim)[0]), (basis.dim)[1]])
      coef = reform(coef, [(basis.dim)[1], gra.dim])
      logger, 'contains ', helpform('basis',basis),  helpform('coef',coef), ' PA=',pa,' pixscale=',cdelt[1]*3600.

      kern_bin = isa(kern_bin) ? kern_bin : 0
      logger, 'kern_bin', kern_bin
   end

   if isa(basis) and keyword_set(gaussian) then begin ; test PSF
      logger, 'loading gaussian test kernel ', gaussian, ' presmoothed by ', kern_bin
      bdim = basis.dim
      npix = sqrt((bdim)[0])
      basis = fltarr(npix,npix,bdim[1])
      basis[*,*,0] = mophongo.psf(npix=npix,fwhm=gaussian,/norm)
      basis = reform(basis,bdim)
   end

   if keyword_set(bin) then kern_bin = bin

   if arg_present(bin) then bin = kern_bin

   ; @@ shortcut: return cached kernel if position < 1/4 grid step
   ; may not be necessary anymore
   ;else if keyword_set(fast) then if isa(x) and isa(y) and isa(xc) and isa(yc) then $
   ;   if min(abs(xc-x))/(gx[1]-gx[0]) lt 0.25 and min(abs(yc-y))/(gy[0,1]-gy[0,0]) lt 0.25 then return, kernel

 ; adx2y is takes as much time as the kernel interpopation: 1e-4
   if keyword_set(ra) and keyword_set(dec) then ad2xy, ra, dec, ast, x, y
   if not keyword_set(x) then x = gx      ; build full grid if coordinates not given
   if not keyword_set(y) then y = gy

   ksz = sqrt((basis.dim)[0])
   nb = (basis.dim)[1]
   xmin = min(gx[*,0])
   xmax = max(gx[*,0])
   ymin = min(gy[0,*])
   ymax = max(gy[0,*])
   nx = (gx.dim)[0]
   ny = (gy.dim)[1]

   if keyword_set(getbasis) then begin ; @@@ ugly, should just fill it with convenient structure for basis...
      len = nb
      kernel = reform(basis, ksz, ksz, len)
   end else begin
      len =  n_elements(x)
      kernel = fltarr(ksz, ksz, len)
      ; @@@ interpolation is fast, only PCA coeficients, so we can also support irregular grids
      ; @@@ check if interpolation correct.. edge effects/pixel center etc..  use poly_2D ?
      ; @@@ i don't think these coordinates are quite right? it says ok in getpsf.
      ; the wcs / fits standard assumed center of pixel
      for i=0,len-1 do begin   ; coordinates ok, checked!  max(spx) works because image coordinates start at 0
         ix = 1.0*(nx-1)*(x[i]-xmin)/(xmax-xmin) > (-0.5) < (nx-0.5) ; normalized index grid for interpolate
         iy = 1.0*(ny-1)*(y[i]-ymin)/(ymax-ymin) > (-0.5) < (nx-0.5)

         cc =  interpolate(coef, ix, iy, cubic=cubic)   ; extrapolation picks nearest value it seems
         kernel[0,0,i] = reform( basis # cc, ksz, ksz)
         if keyword_set(normalize) then kernel[*,*,i] /= total(kernel[*,*,i])
      end
      xc = x
      yc = y
   end

   if arg_present(ast_kern) then ast_kern = ast

  ; @@@ consolidate warp_image and rebin, then wrap with astro wcs header
  ; if angle or pixel scale in ast_out astrometry differnt, warp result
  ; @@@ clean this up
   if keyword_set(ast_out) then begin
      getrot, ast, pa, cdelt
      getrot, ast_out, pa_out, cdelt_out
      rscl = cdelt[1]/cdelt_out[1]
      tsz_out = oddsize(round(rscl*ksz),div=3)

      if abs(pa-pa_out) gt 1e-3 or abs(rscl-1) gt 1e-3 and rscl gt 1.0 then begin ; upsampling

          kernel_out = fltarr(tsz_out,tsz_out,len)

         ; @@@ check centering and speed with congrid? see congrid.pro seems to
         ; @@@ add an outsize to warp_image
         ; @@@ if cleanup warp image including an outsize and optional flux conserve
         for j=0,len-1 do $       ; cubic interpolation  is needed, even for oversampled kernels
            kernel_out[0,0,j] = warp_image(kernel[*,*,j], 0.0, rscl, (ksz-1)/2., (ksz-1)/2., $
                              dimx=tsz_out, dimy=tsz_out, cubic=-0.5, missing=0.0) / rscl^2

; k=warp_image(extrac(kernel[*,*,j],0,0,tsz_out,tsz_out), 0.0, rscl, (ksz-1)/2., (ksz-1)/2., cubic=-0.5, missing=0.0) / rscl^2
; k1=warp_image(kernel[*,*,j], 0.0, rscl, (ksz-1)/2., (ksz-1)/2., dimx=tsz_out, dimy=tsz_out, cubic=-0.5, missing=0.0) / rscl^2
          return, kernel_out * (kernel_out gt underflow_threshold)
      end
      if abs(pa-pa_out) gt 1e-3 or abs(rscl-1) gt 1e-3 and rscl lt 1.0 then begin ; dowsampling
         if abs(1.0/rscl-round(1.0/rscl)) gt 1e-3 then message, 'non-integer downsampling not supported'
         kernel_out = fltarr(tsz_out,tsz_out,len)
         ;   cubic interpolation  is needed, even for oversampled kernels
         for j=0,len-1 do kernel_out[0,0,j] = rbin(kernel[*,*,j],round(1.0/rscl))
         return, kernel_out
      end
   end

   return, kernel * (kernel gt underflow_threshold)
end
;         kernel_out = extrac(reform(kernel,ksz,ksz,len),0,0,0,tsz_out,tsz_out,len)

;   for i=0,len-1 do begin
;      ckern = interpolate(kern, 1.*(sz[0]-1)*(x[i]-min(gx))/(max(gx)-min(gx)), 1.*(sz[1]-1)*(y[i]-min(gy))/(max(gy)-min(gy)), missing=0.,cubic=-0.5);
 ;     kernel[0,0,i] = ckern/total(ckern)
;   end
;      kern = reform(kernel,[(kernel.dim)[0:1], gx.dim])
      ; fits file contains nx x ny x nbasis cube, and extension with bintable
      ; of locations and basis coefficients. If there are no coefficients, basis are stars
   ;   basis = readfits(filename+'.fits',h)
   ;   tab=readfits('test.fits',htab, exten=1,/sile)
   ;   ftinfo, htab, tb
   ;   tcol=tb.ttype.compress()
   ;   for i=0,tcol.length-1 do !null = routine_names(tcol[i],ftget(tb,tab,tcol[i]),store=0)


; klpsf
; @@@ too complicated

function mophongo::getpsf, x, y, filename=filename, verbose=verbose, normalize=normalize,$
                  gaussian=gaussian
   common mophongo_psf_com, basis, spx, spy, spci, pscl, xc, yc, psf, fpsf
   compile_opt static

   underflow_threshold = 1e-10
   ; spatial variation interpol can be linear interpol too
   ; -> so expose interface with linear default and cubic/nearest  as options

   ; load new PSF model from disk
   if ~isa(basis) or isa(filename) then if ~filename.equals(fpsf) then begin
      logger, 'loading ', filename
      restore, filename
      fpsf = filename
   end

   if isa(basis) and keyword_set(gaussian) then begin ; test PSF
      logger, 'loading gaussian test psf '
      bdim = basis.dim
      npix = sqrt((bdim)[0])
      basis = fltarr(npix,npix,bdim[1])
      basis[*,*,0] = mophongo.psf(npix=npix,fwhm=gaussian,/norm)
      basis = reform(basis,bdim)
   end

   ; reuse the same psf if the requested PSF is within 0.5 intervals of the grid coordinates
 ;  if isa(x) and isa(y) then begin

   if (size(basis))[0] eq 1 then nb = 1 else nb = (size(basis,/dim))[1]
   tsz = long(sqrt((size(basis,/dim))[0]))   ; @@@ check should take existing grid

   ; @@@ rename spx/spy to gx/gy
   if not keyword_set(x) then x = spx
   if not keyword_set(y) then y = spy

   len =  n_elements(x)
   psf = fltarr([tsz,tsz,len])
   cc = fltarr(nb)
   mx = max(spx)
   my = max(spy)
   sz=size(spx,/dim)
   for i=0,len-1 do begin   ; coordinates ok, checked!  max(spx) works because image coordinates start at 0
      cc = interpolate(spci, 1.*(sz[0]-1)*x[i]/mx, 1.*(sz[1]-1)*y[i]/my)
      cpsf = reform( basis # cc, tsz, tsz)
      if keyword_set(normalize) then psf[0,0,i] = cpsf/total(cpsf) else psf[0,0,i] = cpsf
   end

   !null = check_math(mask=32)
   return, psf * (psf gt underflow_threshold)
end

; nx x ny x nstar cube
; weight nstar list of weights
function mophongo::pca, cube, basis, max_basis=max_basis, max_var=max_var, weight=weight, $
                  rwindow=rwindow, rthreshold=rthreshold, pca_cube=pca_cube, tol=tol

   compile_opt idl2, static

   nstar = (cube.dim)[2]
   tsz = (cube.dim)[0]
   if not keyword_set(tol) then tol = 1e-8
	if n_elements(max_basis) eq 0 then max_basis = ceil(nstar^0.7-0.5)
	max_basis = max_basis < (nstar-1) > 0

   ; weighting with inverse variance (or weaker power if systematics driven)
   imcombine, cube, basis, weight=weight

   logger, 'using ',max_basis+1, ' basis functions', /info

   basis[where(finite(basis) eq 0)] = 0
 	basis /= total(basis,/nan)
   coef =  replicate(1.0,1,nstar)

   ; @@@ TODO use EMPCA or some weighted PCA throughout
   ; @@@ only let if perform on inner part, use average to determine outer wing
   ; if more than 0 basis functions do PCA analysis. Otherwise just use average
   if max_basis gt 0 then begin
      ; @@@ note: in case of 2 stars, the 2nd PCA component is always == 0! doh

      ; subtract mean PSF
      sz = size(rcube,/dim)
      rcube = cube - rebin(basis,tsz,tsz,nstar)
      rcube[where(finite(rcube) eq 0,/null)] = 0.0

      rcomp = pcomp(transpose(reform(rcube,tsz*tsz,nstar)), coeff=coeff, /covar, eigen=ev, var=var, /double)

      if ~keyword_set(max_var) then max_var = 1.0
      cvar = total(var,/cum)
      cvar /= max(cvar)
      max_basis = (max(where(cvar lt max_var))+1) > 1 < (nstar-1)

      logger, 'updating to ',max_basis+1, ' basis functions based on variance ', /info

      pca_basis_full = transpose(rcomp)

      ; @@@ hack: sigmoid window function for basis components... with soft cut at rthreshold
      ; @@@ pca components at large radii are just noise... -> use weighted PCA
      if keyword_set(rwindow) then begin
         if not keyword_set(rthreshold) then rthresh = tsz/5.0
         sm = lambda(x,m,s: 1.0/(1+exp(-(x-m)/s)))     ; sigmoid window
         !null = apermask(tsz,d=rr)
         !null = growthcurve(cube[*,*,0],raper=raper,rhalf=rhalf)
         ww = 1.0-sm(rr, rthresh, 1.5*rhalf*2 < tsz/15.0)
         for i=0,(pca_basis_full.dim)[1]-1 do pca_basis_full[*,i] *= ww
         ; @@@ todo: since I changed the basis slightly
         ; @@@ I should rederive the coefficients by projecting stars onto new windowed basis
      end

      pca_basis = pca_basis_full[*,0:max_basis-1]

      if max(ev) eq 0 then ev=[1,1]  ; add this in case star = 1
      pca_coef = ( transpose(coeff/rebin(ev,nstar,nstar)) )[0:max_basis-1,*]
   end

   if arg_present(pca_cube) then begin
      pca_cube = fltarr(cube.dim)
      for i=0,nstar-1 do  pca_cube[0,0,i] = basis + (isa(pca_coef) ? reform((pca_coef[*,i] ## pca_basis),tsz,tsz) : 0.0)
   end
;	if isa(pca_basis) then basis = [[[basis]],[[reform(pca_basis,tsz,tsz,max_basis)]]]
	if isa(pca_basis) then basis = [[reform(basis,tsz*tsz)], [pca_basis]]
   if isa(pca_coef) then coef = [coef,pca_coef]

;	help, basis,pca_coef
	return,  { basis:float(basis), coef:float(coef) }
end

; looks good, @@@ plots
 ;  tvs, cube,mm=[-1,1]*1e-5,os=0.5
 ;  tvs, pca_cube,mm=[-1,1]*1e-5,os=0.5
 ;  tvs, cube-pca_cube,mm=[-1,1]*1e-5,os=0.5
;
;   gc = growthcurve(cube,raper=raper)
;   gcp =  growthcurve(pca_cube,raper=raper)
;   for i=0,(gc.dim)[1]-1 do $
;      if i eq 0 then cgplot, raper, (gc/gcp)[*,0], xr=[0.5,tsz/2],yr=[0.98,1.02],/xlog $
;      else cgplots, raper, (gc/gcp)[*,i], lines=2, col='black'


   ; moffat or powerlaw oesnt help on average
;   if ncol eq 8 then aa[7,*,*] = psf_moffat(npix=kern.dim,fwhm=2.0*rhalf_phot,beta=1.5,/norm)
; @@@ windowed FFT deconv is really fast, but breaks on marginally sampled kernels
; @@@ others essentially break too (e.g. iterative ML), but more gracefully
; @@@ would it help to simple oversample image by x2 ?
; get kernel to convolve img1 to img2
; basis must be in fft(basis_i)
; img1 and img2 must have same dimensions and square
; coeff returns best fitting coefficients
pro mophongo::decon_pix, img1, img2, basis, verbose=verbose

  if not keyword_set(cthresh) then cthresh=0.0
  if not keyword_set(ll_method) then ll_method = 3
  s = (size(img1))[1]
  len = s*s
  nb=(size(basis))[3]

stop

; faster in real space
  if isa(basis,/float) then begin
       lax = fltarr(nb,len)

       for i=0,nb-1 do lax[i,*] = fconvolve(basis[*,*,i],img1)

       kern = la_least_squares(lax, img2[*], residual=lares, method=ll_method) ; get minimum norm solution

stop

  end
end

function mophongo::getirac_basis
   common mophongo_aor_com, mpsf, hpsf, map, hmap, current_psf, center_box

stop

   adxy, hmap, ra, dec, x, y
   ix = round(x)
   iy = round(y)

   sz2 = ((mpsf.dim)[0]-1.0)/2.0
   rscl = pixscale(hpsf)/pixscl
   tsz = oddsize(round(rscl*(mpsf.dim)[0]),div=3)

   ww =  map[ix,iy,0,*]     ; could interpolate for finer grid result
   wpa =  map[ix,iy,1,*]    ;
   wh = im_hist1d(wpa, ww, binsize=2, obin=xh)

 ; get most prominent directions, put into basis vector
   dif = convol(wh,[-1,2,-1])
   i =  where(dif gt max(dif)/5.0)

   pa_list = xh[i]
   psf_basis = fltarr(n_elements(pa_list),tsz,tsz)

   foreach a, pa_list, j do $
      psf_basis[j,*,*] = warp_image(extrac(mpsf,0,0,tsz,tsz), a + pa, rscl, sz2, sz2, cubic=-0.5, missing=0.0)

   return, psf_basis
end


; get typical rotation angle from ab IRAC stack
function mophongo::getirac_basis_old, ra, dec, pa, pixscl
   common mophongo_aor_com, mpsf, hpsf, map, hmap, current_psf, center_box

   adxy, hmap, ra, dec, x, y
   ix = round(x)
   iy = round(y)

   sz2 = ((mpsf.dim)[0]-1.0)/2.0
   rscl = pixscale(hpsf)/pixscl
   tsz = oddsize(round(rscl*(mpsf.dim)[0]),div=3)

   ww =  map[ix,iy,0,*]     ; could interpolate for finer grid result
   wpa =  map[ix,iy,1,*]    ;
   wh = im_hist1d(wpa, ww, binsize=2, obin=xh)

 ; get most prominent directions, put into basis vector
   dif = convol(wh,[-1,2,-1])
   i =  where(dif gt max(dif)/5.0)

   pa_list = xh[i]
   psf_basis = fltarr(n_elements(pa_list),tsz,tsz)

   foreach a, pa_list, j do $
      psf_basis[j,*,*] = warp_image(extrac(mpsf,0,0,tsz,tsz), a + pa, rscl, sz2, sz2, cubic=-0.5, missing=0.0)

   return, psf_basis
end


; merge with make model
function mophongo::make_model_fast, src, scale,  index=index, id=id, inn=inn, clean=clean, residual=residual, $
   distance=distance, detection=detection, phot=phot, winx=winx, winy=winy, outsize=outsize, stopme=stopme, full=full
   if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

    inn = self.overlap(src, index, id=id, distance=distance)

   bin = self.param.fit_bin
   model = fltarr((*self.photimg).dim/bin)
   tsz = ((src[0].tmpl).dim)[0]

   xmin  =  (src.xmin-1)/bin
   ymin  =  (src.ymin-1)/bin

   foreach i, inn do begin
      if scale[i] eq 0.0 then continue
      model[xmin[i]:xmin[i]+tsz-1,ymin[i]:ymin[i]+tsz-1] +=  src[i].tmpl*scale[i]
      if i mod 2 then statusline, 'adding to model '+i.tostring()+'/'+(inn.length).tostring()
   end
  if keyword_set(full) then model = shift(rbin(model,bin,/expand,interp=interp,cubic=cubic),1,1)
  if keyword_set(stopme) then stop
  return, model
end

function mophongo::make_model, src, scale,  index=index, id=id, inn=inn, clean=clean, residual=residual, $
   distance=distance, detection=detection, phot=phot, winx=winx, winy=winy, outsize=outsize, $
   cube=cube, full=full, showme=showme, stopme=stopme

   if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1
   bwinx = [1#src.xmin, 1#src.xmax]
   bwiny = [1#src.ymin, 1#src.ymax]
   bin = self.param.fit_bin
   w =  (src[0].tmpl.dim)[0]*bin

   if bin gt 1 and self.param.fit_fast then begin  ; build in  binned coordinates
      model = fltarr((shmvar('model')).dim/bin)
      w = w/bin
      xmin = (src.xmin-1.0)/bin
      ymin = (src.ymin-1.0)/bin
      bwinx = (bwinx-rebin([1,bin],2,bwinx.length))/bin
      bwiny = (bwiny-rebin([1,bin],2,bwiny.length))/bin
      if arg_present(residual) then phot = rbin(shift(*self.photimg,-1,-1),3) else phot=shmvar('phot')
      if arg_present(detection) then det = rbin(shift(*self.detimg,-1,-1),3) else det=shmvar('det')
   end

   ; list of all prior elements overlapping the current tile
   inn = self.overlap(src, index, id=id, distance=distance)

   if n_elements(id) eq 1 or n_elements(index) eq 1 then begin
      model = fltarr(w,w)
      winx = bwinx[0:1,index]
      winy = bwiny[0:1,index]
   end else begin
      if bin gt 1 and self.param.fit_fast then model = fltarr((shmvar('model')).dim/bin) $
         else model = shmvar('model') * 0.0
      winx = [0,(model.dim)[0]-1]
      winy = [0,(model.dim)[1]-1]
   end

   if keyword_set(outsize) then oloc = outsize[0]/2-model.dim/2
   if arg_present(cube) then cube=fltarr([model.dim,inn.length])

   foreach i, inn, ii do begin
      if scale[i] eq 0.0 then continue

      rect_intersect, winx, winy, bwinx[0:1,i], bwiny[0:1,i], ox, oy, omx, omy, oix, oiy, is_empty=is_empty

      if self.param.fit_fast and bin gt 1 then begin  ; @@@ NB: doesnt deal with edge effects
; ok!         model[xmin[i]:xmin[i]+w-1,ymin[i]:ymin[i]+w-1] +=  src[i].tmpl*scale[i]
;         rect_intersect, winx, winy, bwinx[*,i], bwiny[*,i], ox, oy, omx, omy, oix, oiy, is_empty=is_empty
      ;   print, oix, oiy  omx, omy
         if keyword_set(cube) then cube[omx[0]:omx[1],omy[0]:omy[1],ii] =  src[i].tmpl[oix[0]:oix[1], oiy[0]:oiy[1]]*scale[i]
         model[omx[0]:omx[1],omy[0]:omy[1]] +=  src[i].tmpl[oix[0]:oix[1], oiy[0]:oiy[1]]*scale[i]
      end else begin

         if bin eq 1 then tmpl = src[i].tmpl $
            else tmpl = congrid(src[i].tmpl, wx, wy, cubic=cubic, interp=interp, /center)

         model[omx[0]:omx[1],omy[0]:omy[1]] +=  tmpl[oix[0]:oix[1], oiy[0]:oiy[1]]*(scale[i]/bin^2)

      end
   end

   if keyword_set(outsize) then begin
      model = extrac(model, -oloc[0], -oloc[1], outsize[0], outsize[0])
      if keyword_set(cube) then cube = extrac(reform(cube,[w,w,inn.length]), -oloc[0], -oloc[1], 0, outsize[0], outsize[0], inn.length)
      winx = winx[0] - oloc[0] + [0,outsize[0]-1]
      winy = winy[0] - oloc[1] + [0,outsize[0]-1]
   end

   if arg_present(residual) then residual = phot[winx[0]:winx[1],winy[0]:winy[1]] - model
   if arg_present(detection) then detection = det[winx[0]:winx[1],winy[0]:winy[1]]

   ; @@@ mostly debugging as inflated model will be too smooth due to binning convolutions
   if bin gt 1 and self.param.fit_fast and keyword_set(full) then model = rbin(model,/expand,3)

   if keyword_set(showme) then begin
      s = mad(model,bad=0,/sample)*100
      cgerase
      cgimage, phot[winx[0]:winx[1],winy[0]:winy[1]], /keep, layout=[2,2,1], /stretch, $
               minv=-s, maxv=s, /axes, xr=winx+[-0.5,0.5], yr=winy+[-0.5,0.5]
      if n_elements(inn) gt 0 then cgplots, src[inn].x, src[inn].y, psym=9,color='green', thick=1, symsize=2
      if n_elements(index) gt 0 then cgplots, src[index].x, src[index].y, psym=9,color='red', thick=2, symsize=2
      cgplots, src.x, src.y, psym=3, color='yellow', thick=1, symsize=1

      cgimage, model, /keep, layout=[2,2,3], /stretch, minv=-s, maxv=s, /axes, xr=winx+[-0.5,0.5], yr=winy+[-0.5,0.5]
      if n_elements(index) gt 0 then cgplots, src[index].x, src[index].y, psym=9,color='red', thick=1, symsize=2

      if arg_present(detection) then begin
         sd = 10*mad(detection,bad=0)
         cgimage, detection, /keep, layout=[2,2,2], /stretch, minv=-sd, maxv=sd, /axes, xr=winx+[-0.5,0.5], yr=winy+[-0.5,0.5]
         if n_elements(index) gt 0 then cgplots, src[index].x, src[index].y, psym=9,color='red', thick=1, symsize=2
      end

      if isa(residual) then begin
         cgimage, residual, /keep, layout=[2,2,4], /stretch, minv=-s, maxv=s, /axes, xr=winx+[-0.5,0.5], yr=winy+[-0.5,0.5]
         if n_elements(index) gt 0 then cgplots, src[index].x, src[index].y, psym=9,color='red', thick=1, symsize=2
      end
   end

   return, model
end

   ; output image size: 1) stamp, 2 full image, (3) explicit outsize
   ;if keyword_set(outsize) and not self.param.fit_fast then begin
   ;   winx = round(src[index].x + [-1,1]*(outsize[0]-1.0)/2.0)
   ;   winy = round(src[index].y + [-1,1]*(outsize[0]-1.0)/2.0)
   ;end else


; matched filter photometry: = total(img_j*img_j) * total(img_j)/total(img_j^2)
; see lupton photomisc, last term is the normalization of filter divided by number
; of effective pixels: here we just do dot product
  ;     timeit, '!null = reform(img_j,img_j.length) ## reform(img_j,1,img_j.length)
  ;     timeit, '!null = total(img_j*img_j)
pro mophongo::save, basis, ata, atb,  filename=filename, force=force
   if not keyword_set(filename) then filename='latest'

   if ~file_test(filename+'.sav') or keyword_set(force) then begin
      logger, 'saving basis to ',filename
      save, basis, atb, file=filename+'.sav'

      pickle = python.import('pickle')
      Python.ata = ata

      Python.run, "f = open('"+filename+".pkl','wb')"
      Python.run, "pickle.dump(ata,f,-1)"
      Python.run, "f.close()"
   end else logger, filename, '.sav already exists.... skipping '

end

pro mophongo::load, basis, ata, atb,   filename=filename
   if not keyword_set(filename) then filename='latest'

   logger, 'loading ', filename+'.sav'
   restore, filename+'.sav'

   pickle = python.import('pickle')
   python.f = python.open(filename+'.pkl','rb')
   >>>ata = pickle.load(f)
   >>>f.close()
   ata = python.ata
end

; update RHS AT dot b
; @@@ check for diagonal elements that are ~ 0
function mophongo::make_RHS, src, cubic=cubic, interp=interp
   compile_opt idl2

   if not keyword_set(cubic) and n_elements(interp) eq 0 then cubic=-0.5

   xmin = src.xmin
   xmax = src.xmax
   ymin = src.ymin
   ymax = src.ymax
   wx = xmax-xmin+1
   wy = ymax-ymin+1
   wxy = src[0].tmpl
   len = src.length
   atb = dblarr(len)
   bin = self.param.fit_bin
;   ww = (smooth(*self.photwht,3,/edge_mirror))[round(src.x),round(src.y)] / bin^2
   faper, *self.photwht, round(src.x), round(src.y), self.param.rhalf_phot/3.0, ww, os=1, /mean
   phot = shmvar('phot')

   for j=0L,len-1 do begin
      if bin eq 1 then img_j = src[j].tmpl $  ; A * w * b
         else img_j = congrid(src[j].tmpl, wx[0], wy[0], cubic=cubic, interp=interp, /center)

         b = phot[xmin[j]:xmax[j], ymin[j]:ymax[j]]
         if bin gt 1 then b = smooth(b,bin+1)     ; smooth for binning just as models

       atb[j] = total(img_j * b) * (ww[j] / bin^2)
       statusline,'Updating RHS '+j.tostring()+'/'+len.tostring()
   end

   return, atb
end


;@@@@ skicit learn 2.6
;@@@@This is why it makes sense to estimate a sparse precision matrix: by learning independence ;
; relations from the data, the estimation of the covariance matrix is better conditioned. This is known as covariance selection.
;
; normal matrix of AT.A = AT.b
pro mophongo::make_normal, src, ata, atb, append=append, update=update, background=background, $
                     weight_gaussian=weight_gaussian, noisefloor=noisefloor, sortbright=sortbright,$
                      stopme=stopme, verbose=verbose
   compile_opt idl2

   if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

   if n_elements(update) eq 0 then update = 0B
   if n_elements(append) eq 0 then append = 0B
   sparse = python.import('scipy.sparse')
   python.run, 'import numpy as np'

  ; cut bloat here
   bin = self.param.fit_bin
   dim = src.dim                ; dimension of image stamp in det coordinates
   buf = 3L                     ; minimum overlap in x and y between src i and each j
   len = src.length
   xmin = src.xmin
   ymin = src.ymin
   xmax = src.xmax
   ymax = src.ymax
   wx = xmax-xmin + 1
   wy = ymax-ymin + 1
   bx = src.x
   by = src.y
   rlim = max(wx>wy)

   ;  update, append, or initiate a sparse matrix
   if isa(ata) and append then begin   ; append to existing ata: 1) extend array, 2) when adding elements count backwards
       python.a = ata.tocoo()        ; @@@ following should be ok, but test
       python.run,'a = sparse.coo_matrix((np.append(a.data,0.0), (np.append(a.row,'+strn(len)+'),  np.append(a.col,'+strn(len)+'))))'
       ata = (python.ata).tolil()
       index = lindgen(len,start=(ata.dim)[0])
   end else if isa(ata) and update then begin
      python.ata = ata.tolil()
      index = update
   end else begin  ; create new     ;   if isa(background) then background=0.0
      Python.Run, 'ata = sparse.lil_matrix(('+strn(len)+','+strn(len)+'))'
      ata = Python.ata
      atb = dblarr(len)
      index = lindgen(len)
   end

   ; @@@@ assumes phot image is on det scale; @@@ check: if phot not transformed to det then x,y positions wrong -> ra,dec
   fpeak = (*self.photimg)[round(bx),round(by)]
   faper, *self.photwht , bx, by, self.param.rhalf_phot/3.0, ww, os=1, /mean

  ; precalculate inproduct of PSF as a function of separation (used later to predict sparsity cut off)
   extast, headfits(self.fdet), adet   ; @@@ could do quicker, in binned scale and multiply by bin
   tt = rbin(self.getkernel(median(src.ra), median(src.ra), ast_out=adet))
   for i=0,(tt.dim)[0]-1 do ff = append(ff, total(tt*imshift(tt,i*0.707,i*0.707),/nan))

   ; cutting inproduct on radius (when below noise floor): calculate brightest first
   ; so always uses largest rlim_snr and overlap with fainter source is always calculated
   if keyword_set(sortbright) or isa(noisefloor) then index = index[reverse(sort(fpeak[index]))]
   rtile = (wx[index] > wy[index])/2.
   bx = bx[index]
   by = by[index]

   if bin gt 1 and self.param.fit_fast then begin  ; inproduct in binned coordinates
       ; @@@@ hmmm need to offset phot by -1,-1 ???
      phot = rbin(shift(*self.photimg,-1,-1),bin)  ; note... this is now a local copy
      xmin = (xmin-1.0)/bin
      ymin = (ymin-1.0)/bin
      wx = wx/bin
      wy = wy/bin
   end else phot = shmvar('phot')

   ; build sparse matrix AT * A, row by row, build AT 8 b
   foreach j, index, jj do begin

      ; img_j = src[j].tmpl * ww[j]  ;  AT * ivar  ; note postpone ww and bin^2 scaling until total()
      if bin eq 1 or self.param.fit_fast then img_j = src[j].tmpl else $
         img_j = congrid(src[j].tmpl, wx[0], wy[0], cubic=cubic, interp=interp, /center)

      ; AT * b * ivar
      if arg_present(atb) then begin
         b = phot[xmin[j]:xmin[j]+wx[j]-1,ymin[j]:ymin[j]+wy[j]-1]
         atb[j] = total(img_j * b) * ww[j] / bin^2
 ;        if isa(background) then background += total(b)*ww[j]
      end

      ; only consider sources to a radius where its PSF profile is > noisefloor
      if keyword_set(noisefloor) then rlim = interpol([0:ff.length-1],(fpeak[j]*sqrt(ww[j])>1)*sqrt(ff/ff[0]),noisefloor)

      ; check for overlapping bases, cull on distance between j and i
      ; - default: built full matrix in incremental mode (default)
      ; - update: consider full row
      ; - append: consider all preceding (in enlarged matrix, so count until index)
      if update then ij = [0:len-1] else if append then ij = [0:jj] else ij = [jj:len-1]
      sij = sqrt( (bx[jj] - bx[ij])^2 + (by[jj] - by[ij])^2 )
      icol = where(sij lt (rtile[jj]+rtile[ij]-buf) < rlim, ncol, /null)

      ; calculate AT dot A cross terms for every overlapping src i,j on row j
      if keyword_set(append) or keyword_set(update) then irow = index[icol] else irow = index[jj + icol]

      ata_row = fltarr(ncol)        ; collect dot products in sparse row
      for k=0L,ncol-1 do begin
          i = irow[k]
         ; @@@ push this to overlap rect?
         ; overlap in local src j
          jx1 = (xmin[i] - xmin[j]) > 0 < (wx[j] - 1)
          jy1 = (ymin[i] - ymin[j]) > 0 < (wy[j] - 1)
          jx2 = (xmax[i] - xmin[j]) > 0 < (wx[j] - 1)
          jy2 = (ymax[i] - ymin[j]) > 0 < (wy[j] - 1)
          ; overlap in local src i
          ix1 = (xmin[j] - xmin[i]) > 0 < (wx[i] - 1)
          iy1 = (ymin[j] - ymin[i]) > 0 < (wy[i] - 1)
          ix2 = (xmax[j] - xmin[i]) > 0 < (wx[i] - 1)
          iy2 = (ymax[j] - ymin[i]) > 0 < (wy[i] - 1)

         if bin eq 1 then imi = src[irow[k]].tmpl else begin
            if self.param.fit_fast then $
               imi = extrac(src[i].tmpl, xmin[j]-xmin[i], ymin[j]-ymin[i], wx[j], wy[j]) $
            else $
               imi = congrid(src[irow[k]].tmpl, dim[0], dim[1], cubic=cubic, interp=interp, /center)
         end

       ; dot product imj * imi * ww on overlap = AT * A * ivar ; bin^4 = flux scaling for imj and imi
       if self.param.fit_fast then  ata_row[k] = total(img_j*imi) * (ww[j]/bin^2) else $
          ata_row[k] = total(img_j[jx1:jx2, jy1:jy2] * imi[ix1:ix2,iy1:iy2]) * (ww[j]/bin^4)
     end

      ; threshold always > 0.0
      ata_row[where(ata_row lt max(ata_row)*self.param.fit_sparse_threshold,nz,/null)] = 0.0

      if keyword_set(verbose) then logger, jj, src[j].id, rlim, ncol,  ncol-nz, cubic

      ; put indexed row in sparse matrix
      ; index i is offset from diagional j if building upper triangle of full matrix
      python.jpicol = irow
      python.ata_row = ata_row
      Python.Run, 'ata['+j.tostring()+',jpicol] = ata_row'

      ; update: also put in column to make symmetric
      if keyword_set(update) then begin
          python.ata_row = reform(ata_row,1,ncol)
          Python.Run, 'ata[jpicol,'+j.tostring()+'] = ata_row'
      end

      statusline, 'building normal equations '+jj.tostring()+'/'+len.tostring()
      !null = check_math(mask=32)
   end

   ata = Python.ata
   ata = ata.tocsr()
   if keyword_set(stopme) then stop
   if keyword_set(update) then return                    ; if update we're already symmetric
   if keyword_set(append) then ata = ata.tril()          ; else make symmetric
   ata = ata + ata.transpose() - sparse.diags(ata.diagonal())
end

   ; @@@ this doesnt work yet
;   if keyword_set(background) and not keyword_set(update) and not keyword_set(append) then begin
;       logger, 'adding background',/info
;       python.ivar = 1.0/src.eflux_model^2
;       Python.Run, 'ata[-1,0:-1] = ivar'             ; inproduct of template always 1.0
;       Python.Run, 'ata[-1,-1] = ivar.sum()'
;       atb[-1] = background
;   end

        ; wx[0] ?? shouldnt this be the index the row?  i.e. len
;       python.run,'nr = np.append(ata.row,'+wx[0].tostring()+')'
;       python.run,'nc = np.append(ata.col,'+wy[0].tostring()+')'
;       python.run,'nd = np.append(ata.data,0.0)'
;       python.run,'nr = np.append(a.row,'+strn(len)+')'
;       python.run,'nc = np.append(a.col,'+strn(len)+')'
;       python.run,'nd = np.append(a.data,0.0)'
;       python.run,'ata = sp.coo_matrix((nd, (nr, nc)))'
   ;   if keyword_set(update) then begin
   ;      sji = sqrt( (bx[jj] - bx)^2 + (by[jj] - by)^2 )
   ;      icol = where(sji lt rtile[jj]+rtile-buf, ncol, /null)
   ;   end else if keyword_set(append) then begin            ; append at end, count from start 0:jj
   ;      sji = sqrt((bx[jj] - bx[0:jj])^2 + (by[jj] - by[0:jj])^2)
   ;      icol = where(sji lt rtile[jj]+rtile[0:jj]-buf, ncol, /null)
   ;   end else begin                                        ; full matrix only upper triangle jj:*
   ;      sji = sqrt( (bx[jj] - bx[jj:len-1])^2 + (by[jj] - by[jj:len-1])^2 )
   ;      icol = where(sji lt (rtile[jj]+rtile[jj:len-1]-buf) < rlim, ncol, /null)
   ;   end

;if keyword_set(stopme) then begin
;   print, src[j].id, src[j].x, src[j].y, src[j].xmin,src[j].ymin, (src[j].x-src[j].xmin-1)/3.0, (src[j].y-src[j].ymin-1)/3.0, (src[j].xmin-1)/3.0
;   print, src[i].id, src[i].x, src[i].y, src[i].xmin,src[i].ymin, (src[i].x-src[i].xmin-1)/3.0, (src[i].y-src[i].ymin-1)/3.0, (src[i].xmin-1)/3.0
;   sclj = max(b*(img_j gt 7e-3))/max(img_j)
;   scli = max((b-sclj*img_j)*(imi gt 7e-3))/max(imi)
;   tvs,b
;   tvs,b-img_j*sclj,pos=1
;   if i ne j then tvs,b-img_j*sclj - imi*scli, pos=1
;   junk=gauss2dfit(img_j,g) & print,g
;   if  self.param.fit_fast then w = (ww[j]/bin^2) else w = (ww[j]/bin^4)
;   print, ' j   i ', j, i,  '      id ', src[j].id, src[i].id
;   print,'ajj',total(img_j^2) * w
;   if  self.param.fit_fast then  print,'aji',total(img_j*imi) * w else print, total(img_j[jx1:jx2, jy1:jy2] * imi[ix1:ix2,iy1:iy2]) * (ww[j]/bin^4)
;   print,'atb', total(img_j * b) * w
;   print, ata_row
;   stopkey
;end
; ok!
;print,  src[j].x,src[j].y
;bo = phot[xmin[j]:xmax[j], ymin[j]:ymax[j]]
;tvs,center(bo,/ch),fac=500
;tvs,center(congrid(src[j].tmpl, wx[0], wy[0], cubic=cubic, interp=interp, /center),/ch)
;tvs, bo-congrid(src[j].tmpl, wx[0], wy[0], cubic=cubic, interp=interp, /center)*11080.
;tvs,center(shift(img_j,-1,1),/ch)
;tvs,center(img_j,/ch)
;b = (*self.photimg)[xmin[j]:xmax[j], ymin[j]:ymax[j]]
;bb = rbin(b,bin)
;tvs,center(bb,/ch)
;tvs, bb - img_j*11.08e3*9
;src[irow[k]].tmpl
;imjc = imj[jx1:jx2, jy1:jy2]
;imic = imi[ix1:ix2,iy1:iy2]
;old(x,y) -> new(x,y):  201.71 201.52 -> 202.00 202.00, should be:  202.00 202.00 image size:   405  405
;old(x,y) -> new(x,y):  201.17 201.95 -> 202.00 202.00, should be:  202.00 202.00 image size:   405  405
;print, jx1,jx2, jy1,jy2
;print, ix1,ix2, iy1,iy2
; j 562  -    2578.70      1117.51 -  2377         916
; j          9         404           0         375
; i 540  -    2587.17      1088.95  - 2386         887
; i          0         395          29         404
; so  1) (xmin - 1) must be divisable by 3: i.e. 4 -> 1, 10 -> 3 (10 + 0.5)/3 - 0.5 = 3
;         offset by shx = (xmin-1) mod 3
; xmin=lindgen(7)+7 & print, xmin, (xmin-1) mod 3, (xmin-1)/3.
; binned coordinates
;  xb = (x - 1)/3.0
;  x = xb * 3.0 + 1.0
; and 2) then translate (xmin + 0.5)/bin +
;      if keyword_set(verbose) and 0 then begin
;         mm=[-3,3]*1/sqrt(ww[j])
;         cgimage, b, /str,minv=mm[0], maxv=mm[1],/keep,layout=[2,1,1],xr=bx[jj]+[-202,202],yr=by[jj]+[-202,202]
;         cgimage, b*apermask(b.dim,rlim/2), /str,minv=mm[0], maxv=mm[1],/keep,layout=[2,1,2],xr=bx[jj]+[-202,202],yr=by[jj]+[-202,202]
;         cgplot,bx[jj+icol],by[jj+icol],psym=9,/overplot,col='green'
;         cgplot,[bx[jj]],[by[jj]],psym=9,symsize=4,/overplot,col='red'
;         cgplot,src[irow].x,src[irow].y,psym=6,col='blue',/overplot,symsize=1.5
;         stopkey
;      end

; remove list of basis_i from normal equations
; by deleting corresponding rows and columns
; remove rows and columns given by index
function mophongo::remove_normal, ata_in, index, atb=atb, iok=iok
  ata = ata_in
  iok = cgSetDifference(lindgen(ata.shape[0]),index)

  if keyword_set(atb) then atb = atfb[iok]

  python.iok = iok
  python.ata = ata
  python.run, 'ata = ata.tocsr()[iok, :].tocsc()[:, iok]'
  ata = python.ata

  return, ata
end

; normal matrix of AT.A = AT.b
; update existing normal matrix with prior constraints
pro mophongo::regularize_normal, ata, atb, fprior, eprior, index=index, stopme=stopme
   compile_opt idl2

   if not keyword_set(index) then index = lindgen(atb.length)

   ata = ata.tocoo()

   d = ata.diagonal()
   d[index] += 1.0/eprior^2
   !null = ata.setdiag(d)

   atb[index] += fprior / eprior^2

   ata = ata.tocsr()

   if keyword_set(stopme) then stop
end

; normal matrix of AT.A = AT.b
; update existing normal matrix with prior constraints
function mophongo::covariance, ata, scale, threshold=threshold, stopme=stopme
   compile_opt idl2

   if not keyword_set(threshold) then threshold=1e-5

   a = ata.tocoo()
   aa=a.todense()
   aai = invert(aa)

;   plot, sqrt(diagonal(aai))
;   nn = total(aa)
;   print, 1.0*n_elements(where(aa ne 0))/n_elements(aa)
;   aa -= rebin(mean(aa,dim=1),dim)
;   c = aa # aa / nn^2
;   plot, c.diagonal()

   dim = a.shape.toarray()
   nn = dim[0]-1

; this is not right, because it is not ever using the zero components
   am = a.mean(0)
   data = a.data
   for i=0,dim[0]-1 do data[where(a.row eq i,n)] -= am[i]*dim[0]/n
   a.data = data

   a = a.tocsr()
   a = a.dot(a) / (dim[0]-1)

   if keyword_set(stopme) then stop

   a = a.tocoo()
   dm = a.diagonal()
   data = a.data
   for i=0,dim[0]-1 do begin &$
      j=where(a.row eq i) &$
      data[j] *= abs(data[j]) gt dm[i]*threshold &$
   end
   a.data = data

   return, a.multiply(a gt dm*self.param.fit_sparse_threshold)
end
;    # the correlation coefficients are given by
;    # C_{i,j} / sqrt(C_{i} * C_{j})
;    d = np.diag(C)
;    coeffs = C / np.sqrt(np.outer(d, d))
;
;If your curve fit is unconstrained and your residual has uniform variance s2, then a common approximation to the covariance matrix of the parameters is
; Cov=inv(J'*J)*s2
;where J is the Jacobian of the residual at the solution. Both LSQCURVEFIT and LSQNONLIN return the Jacobian as an optional output argument
;I saw that CovB = inv(J'*J)*MSE in a MATLAB documentation here at http://www.mathworks.com/help/stats/nlinfit.html
 ;http://stats.stackexchange.com/questions/231868/relation-between-covariance-matrix-and-jacobian-in-nonlinear-least-squares
; http://stats.stackexchange.com/questions/10795/how-to-interpret-an-inverse-covariance-or-precision-matrix
;http://stats.stackexchange.com/questions/73463/what-does-the-inverse-of-covariance-matrix-say-about-data-intuitively
;     cov= inv(ATwwA)
;  standard approximation to the Hessian of a nonlinear least squares problem used by Gauss-Newton and Levenberg-Marquardt algorithm
;Consider the nonlinear least squares problem: minimize 1/2r(x)Tr(x)
;. Let JJ = Jacobian of r(x). The Hessian of the objective = JTJ+JTJ
; higher order terms. The Gauss-Newton or Levenberg-Marquardt approximation is to ignore the higher order terms, and approximate the Hessian as JTJ
; . This approximation for the Hessian is what is used in the formula CovB = inv(J'*J)*MSE in MATLAB's nlinfit.
;The higher order terms are close to zero at the solution if the residuals r(x) are close to zero. If the residuals are large at the solution, the approximation may be very inaccurate. See the first 7 slides of https://www8.cs.umu.se/kurser/5DA001/HT07/lectures/lsq-handouts.pdf . There is also mention, with less detail provided, at https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm.

; ------- subtract background on residual image, masking objects
; @@@ check if this works again -> make sure image is at least somewhat background subtracted to begin with
pro mophongo::background, src, scale, stopme=stopme,  residual=residual, skyimage, interp=interp, _extra=extra
   logger, 'subtracting background', /info
   if not keyword_set(bgwidth) then bgwidth = self.param.phot_background_factor*self.param.rhalf_phot
   if not keyword_set(bgthresh) then bgthresh = 3.0     ; @@@@ set as autopilot parameter

   bin = ceil(self.param.phot_minradius/pixscale(self.fdet)) > ceil(self.param.rhalf_phot/2.0)
   objmask = smooth(abs(self.make_model(src, scale, residual=residual, interp=interp)) lt sqrt(1.0/*self.photwht), self.param.rhalf_phot)

; huge memory use here ???? ; @@@@ should rederive sigma here....
; this hear eats memory, maybe return only at binned resolution ?
   !null = skysub(residual*(*self.detimg ne 0), *self.photwht, bin=bin, skyimage=skyimage, bgwidth=bgwidth, $
               thresh=bgthresh, mask=objmask, rmsimage=rmsimage, stopme=stopme, reject_fraction=0.01,  _extra=extra)

   *self.photimg -= skyimage
    report_memory
end
 ;  optionally keep and memmap background map
 ;  if keyword_set(self.param.fit_memmap) then *self.photimg -= self.memmap(skyimage, name='sky', file=self.param.fit_memmap) $
 ;  else *self.photimg -= temporary(skyimage)
;    if keyword_set(stopme) then stop

function mophongo::solve, src, ata, atb, model=model, residual=residual, fsig=fsig, fres=fres, $
                   regul_neg=regul_neg, regul_res=regul_res, stopme=stopme
   if not keyword_set(regul_neg) then regul_neg = 0
   if not keyword_set(regul_res) then regul_res = 0
   thresh = self.param.fit_neg_threshold
   bin = self.param.fit_bin

   la = python.import('scipy.sparse.linalg')
   scale = (la.cg(ata.tocsr(), atb, tol=self.param.fit_tol))[0]

; ----- regularize negativity fits ------------
   logger, 'regularize negative fits ', /info
   for i=0,regul_neg-1 do begin
      ibad = where(scale/src.eflux_model lt thresh, nbad)
      if nbad eq 0 then continue
      self.regularize_normal, ata, atb, fltarr(ibad.length), src[ibad].eflux_model, index=ibad
      scale = (la.cg(ata, atb,tol=self.param.fit_tol))[0]
      logger, i, nbad, ' regul neg '
   end

   if keyword_set(regul_res) then begin

      model = self.make_model(src, scale, residual=residual)

      faper, 1.0/*self.photwht , src.x, src.y, self.param.rhalf_phot/2.0, fsig, os=1
      fsig = sqrt(fsig)
      x = src.x
      y = src.y

; @@@ test this on fast mode
     if self.param.fit_fast and bin gt 1 then begin
        x = (src.x-1)/bin
        y = (src.y-1)/bin
        pw = rbin(shift(*self.photwht,-1,-1),3)
        faper, 1.0/pw,  x, y, self.param.rhalf_phot/2.0/bin, fsigb, os=1
        fsigb = sqrt(fsigb)*bin^2
      end

      for i=0,regul_res-1 do begin
         if i eq 0 then logger, 'regularize fits with strong residuals', /info

         snr = scale/src.eflux_model
         faper, residual, x, y, self.param.rhalf_phot/2.0/bin, fres, os=1

; @@@ test this on fast mode
         ibad = where(fres/fsig lt thresh or (snr lt thresh and fres/fsig gt -thresh), nbad, complement=iok)

         fprior = (scale[ibad] + 2.0*(fres/fsig)[ibad]*src[ibad].eflux_model ) > 0.0
         eprior = src[ibad].eflux_model

         self.regularize_normal, ata, atb, fprior, eprior, index=ibad

         scale= (la.cg(ata, atb, tol=self.param.fit_tol))[0] > (thresh*src.eflux_model)

         model = self.make_model(src, scale > ((i eq regul_res-1) ? 0.0 : (-1e30)), residual=residual)
         logger, i, nbad, ' regul res '
      end
   end

  report_memory
  return, scale
end


; @@@ which pixel scale to use -> can we work in downsampled space, without loss of accuracy ?
function mophongo::centroid, src, scale, stopme=stopme, method=method, test=test, step=step, $
                  usefit=usefit, rlim=rlim, stopmp=stopmp, _extra=extra

   if not keyword_set(step) then step=0.5
   logger, 'registration using bright objects SNR > ', self.param.register_snrlim, /info

; @@@ don't use blended priors model fluxes
; sort in brightness, brightest first.
; model nearest 6 sources simultaneously -> but skip them later
; i.e. sort brightness first,  only do it for the brightest in tile then skip the other ones
   ; ---- fit models to IRAC bright sources to get spatial offset -> map it and apply

   bin = self.param.fit_bin
   if bin gt 1 and self.param.fit_fast then begin
      photimg = rbin(shift(*self.photimg,-1,-1),3)
      detimg = rbin(shift(*self.detimg,-1,-1),3)
      errimg = 1.0/sqrt(rbin(shift(*self.photwht,-1,-1),3))
   end else begin
      phot=shmvar('phot')
      det=shmvar('det')
      photwht=shmvar('photwht')
   end

   if not keyword_set(scale) then begin
      scale = fltarr((src.id).length)
      for i=0,scale.length-1 do scale[i] = photimg[(src[i].x-1)/bin,(src[i].y-1)/bin]/max(src[i].tmpl)
      stop
   end

   snr = scale/src.eflux_model
   icentroid = where(snr gt self.param.register_snrlim and src.parent_id eq 0, /null, ncentroid)
   icentroid = icentroid[reverse(sort(snr[icentroid]))]
   dxy = fltarr(9,ncentroid)
   detmask = (*self.detimg ne 0)

   if ncentroid eq 0 then message, ' no valid sources '
   skip = bytarr(ncentroid)
   for i=0,ncentroid-1 do begin
      if skip[i] then continue
      s = src[icentroid[i]]

      ; @@@ should do kernel dimension or original object dimension, whichever is biggest...
      if not keyword_set(rlim) then rlim = ceil(self.param.rhalf_phot*3.0/bin  >  src[0].dim/5/bin)
      ; fit to absolute scale, so no models are 0, but also not negative
      model = self.make_model(src, scale, index=index, id=s.id, distance=rlim[0]*2.5, inn=inn, $
                              outsize=oddsize(rlim), cube=cube, winx=winx, winy=winy)

      obs = photimg[winx[0]:winx[1], winy[0]:winy[1]]
      err =  errimg[winx[0]:winx[1], winy[0]:winy[1]]*bin^2
      det =  detimg[winx[0]:winx[1], winy[0]:winy[1]]

      ; @@ hardwired if object is not dominant object in local stamp: hardwired to 75% of total
      fractot = scale[icentroid[i]]/total(model)
      if fractot lt 0.70 then continue

      if  1 or s.flux_peak gt 5 and keyword_set(stopme) then begin
         if ~isa(perror) then window,1, xs=1200,ys=200
         ss = mad(obs)*2
         tvs, obs-model, mm=[-1,1]*ss
         tvs, smooth(obs-model,3), mm=[-1,1]*ss, pos=1
         tvs, model, mm=[-1,1]*mad(obs)*15,pos=2
         tvs, obs, mm=[-1,1]*mad(obs)*15,pos=3
         tvs, det, mm=[-1,1]*3e-3,pos=4
         print, 'current source:', icentroid[i], s.id, s.x, s.y
      ;   stopkey,/silent
      end

      ; all sources ins stamp have flux = free parameter, rest put in fixed background
      dr = sqrt((src[inn].x-src[icentroid[i]].x)^2 + (src[inn].y-src[icentroid[i]].y)^2)

      stop
      imodel = where(dr/bin lt max(model.dim)/2,nmodel)
      if nmodel lt inn.length then cube =  [ [[cube[*,*,imodel]]], [[model - total(reform(cube[*,*,imodel],[(cube.dim)[0:1],nmodel]),3)]] ]
      if cube.ndim eq 2 then cube = reform(cube, [cube.dim,1])
      nmodel = (cube.dim)[2]

;nmodel=1
      parinfo = replicate({value:1D, fixed:0, step:1.0D, limited:[0,0], limits:[0.D,0]}, nmodel+2)
      parinfo.step = [1.,1.,0.2+fltarr(nmodel)]*step / [bin,bin,1.0+fltarr(nmodel)]   ;  @@@@ not using binned here
      parinfo[0:1].limits = [-20.,20]/bin               ; @@@ put in parameter
      parinfo[0:1].limited = 1
      start = [0.,0.,1.0+fltarr(nmodel)]
   ;   start = [0.,0.,scale[inn[imodel]]]

;   m = reform(mod_sh,dim[0]*dim[1],dim[2]) # p[2:*]
;for i=0,inn.length-1 do cgimage,cube[*,*,i],layout=[8,6,i],/keep,minv=-1e-4,maxv=1e-4 ; ,os=1,mm=[-1,1]*1e-3, layout=[8,6,i]
;stopmp=1
;stop
      xyr = mpfit('centroid_multipsf', start, ftol=1e-8, parinfo=parinfo, STATUS=status, $; /nocatch,$
                  nfev=nfev, maxiter=8, BESTNORM=chi2, perror=perror, ERRMSG=errmsg, quiet=1, $ ;resdamp=5*median(err), $
                  functargs={  err:err, obs:obs, model:cube, stopme:keyword_set(stopmp), det:det})
 ;     xyr = mpfit('centroid_multipsf', [0.,0.,1.0], ftol=1e-8, parinfo=parinfo, STATUS=status, $; /nocatch,$
 ;                 nfev=nfev, maxiter=10, BESTNORM=chi2, perror=perror, ERRMSG=errmsg, quiet=1, resdamp=5*median(err), $
 ;                 functargs={  err:err, obs:obs, model:model, stopme:keyword_set(stopmp), det:det})
      dxy[0:1,i] = xyr[0:1] * bin
      dxy[2:3,i] = perror[0:1] * bin
      dxy[4:5,i] = [s.x,s.y]
      dxy[6,i] = s.id
      dxy[7,i] = chi2
      dxy[8,i] = fractot
      statusline, ' deriving distortion map: '+(i).tostring()+' '+(s.id).tostring()+' '+((dxy[*,i]).tostring()).join(' ')
      src[icentroid[i]] = s

      res = centroid_multipsf(xyr, err=err, model=cube, obs=obs)
      rsz = sqrt(res.length)
      if keyword_set(stopme) then tvs, reform(res,[rsz,rsz]), mm=[-1,1]*mad(res)*15,pos=5

    ;  remove inn from from centroid list
    ;  iskip = where_array(inn,icentroid)
      iskip = i
      if skip[0] ne -1 or min(dxy[2:3,i],dim=1) eq 0 then skip[iskip] = 1
      if keyword_set(stopme) then stopkey, /silent
    end

   ; keep only those that dominate local stamp
   ; @@@ save error on x,y measurements     ; @@@ determine error on map
   ; @@@ !!! if we are only interpolating sources, do not grid. grid is fine for visualization
   ; @@@ otherwise better to do kriging directly for the sources
   chilim = percentiles(dxy[7,*],val=0.95)
   iok = where(dxy[0,*] ne 0.0 and dxy[7,*] lt chilim and min(abs(dxy[7,*]),dim=1) ne 0,  nok)
   fmap = self.fphot.replace('sci.fits','fit_shift.pdf')

; @@@ catch if too few....
   forprint, dxy[6,*], dxy[4,*], dxy[5,*], dxy[0,*], dxy[1,*], dxy[2,*], dxy[3,*], dxy[7,*], $
            dxy[8,*], sub=iok, textout=fmap.replace('.pdf','.cat'), $
            comment='# id x y dx dy ex ey chi fractot', form='(i,8g12.5)'

   shifts = regrid(src[icentroid[iok]].x, src[icentroid[iok]].y, dxy[0:1,iok], $
               pscale=pixscale(self.fdet), sigclip=self.param.fit_shift_sigclip, $
               method=method, outfile=fmap,/vectorfield, _extra=extra, /showme)
   id = src[icentroid[iok]].id
   save, id, shifts, file=fmap.replace('.pdf','.sav')
   ; @@@ instead of 'shift' map could instead write a wcs map of 'distorted ra dec'
   ; so that when interpolating onto
   src[icentroid[iok[shifts.iok]]].model_dxy = dxy[0:1,iok[shifts.iok]]

; now interpolate over all other sources
  ; result = krig2d(reform(dxy[0,icentroid[iok]]),src[icentroid[iok]].x, src[icentroid[iok]].y, $
  ;             linear=[src[0].dim[0],0], xout=src[0].x, yout=src[0].y, gaussian=[3,src[0].dim[0]] )
   if keyword_set(method) then TRIANGULATE, src[icentroid[iok[shifts.iok]]].x, src[icentroid[iok[shifts.iok]]].y, tr
   dx = griddata(src[icentroid[iok[shifts.iok]]].x, src[icentroid[iok[shifts.iok]]].y, shifts.zfit[0,*], xout=[src.x], yout=[src.y], method=method, triangles=tr, _extra=extra)
   dy = griddata(src[icentroid[iok[shifts.iok]]].x, src[icentroid[iok[shifts.iok]]].y, shifts.zfit[1,*], xout=[src.x], yout=[src.y], method=method, triangles=tr, _extra=extra)

; ok, but kriging always goes to the measured points ?
;print, [1#dx[icentroid],1#dy[icentroid],dxy]
;print, [shifts.zfit,dxy[*,iok[shifts.iok]]]

   if keyword_set(test) then logger, 'testing only....'
   if keyword_set(test) then return,dxy

   for i=0,src.length-1 do if src[i].model_dxy[0] eq 0 or keyword_set(usefit) then src[i].model_dxy = [dx[i],dy[i]]
   for i=0,src.length-1 do begin &$
      src[i].tmpl = imshift(src[i].tmpl, src[i].model_dxy/bin, cubic=-0.5) &$
      statusline, ' updating positions: '+ (src[i].id).tostring()+' '+((src[i].model_dxy).tostring()).join(' ') &$
   end

   return,src
end

;   ngrid = (size(shifts.gx,/dim))[0]
;   ddx = reform(shifts.gz[0,*,*])
;   ddy = reform(shifts.gz[1,*,*])
;   minx = min(shifts.gx)
;   miny = min(shifts.gy)
;   nx = (dx.dim)[0]
;   ny = (dx.dim)[1]
;   delta = shifts.gx[1]-shifts.gx[0]
;   xyip = fltarr(2,scale.length)
;   for i=0,scale.length-1 do xyip[*,i] = interpolate(shifts.gz, (src[i].x-minx)/delta, (src[i].y-miny)/delta, cubic=-0.3)
;   print, [1#dx, 1#dy, xyip, src.model_dxy]
; print,  [1#dx,1#dy,src.model_dxy,src.model_dxy-[1#dx,1#dy]]
;print,[xyip,src.model_dxy]
;ii = iok[shifts.iok]
;print,[xyip[*,ii],shifts.zfit,src[ii].model_dxy,1#scale[ii]]

;   rmodel = *self.photimg -  self.make_model(src, scale>0.0)
;   cleanplot
;   loadct,0
;   cgWindow_SetDefs, /PS_Encapsulated, aspect=1.0, IM_Width=(*self.photimg)[0]/1.0
;   cgimage, (*self.photimg)[0:3800,0:3800], /keep,/stret,minv=-0.1e-4,maxv=0.1e-4, layout=[1,1,1],  outfile='cen0.pdf', output='pdf'
;   cgimage, rmodel[0:3800,0:3800], /keep,/stret,minv=-0.1e-4,maxv=0.1e-4, layout=[1,1,1],  outfile='cen1.pdf', output='pdf'

;   rmodel = *self.photimg -  self.make_model(src, scale>0.0)
;   cgimage, rmodel[0:3800,0:3800], /keep,/stret,minv=-0.1e-4,maxv=0.1e-4, layout=[1,1,1],  outfile='cen2.pdf', output='pdf'

; @@@  ---- this is wrong. remove
   ; ---- warp photometry image ; check coordinate grid origin.... 0,0  center pixel ?
   ; @@@@ should we always work in binned down for low res image  ?
;   logger, 'applying shift transform to photometry image', /info
;   mkgrid, (*self.photimg).dim, x0, y0, c=[0,0]
;   x0 = self.memmap(x0, name='x0', file=self.param.fit_memmap)
;   mkgrid, phot.dim, !null, y0, c=[0,0]
;   y0 = self.memmap(y0, name='y0', file=self.param.fit_memmap)
;   report_memory
;   ngrid = (size(gx,/dim))[0]
;   dx = reform(shifts.gz[0,*,*])
;   dy = reform(shifts.gz[1,*,*])
;   minx = min(shifts.gx)
;   miny = min(shifts.gy)
;   ngridx = (dx.dim)[0]
;   ngridy = (dx.dim)[1]
;   ; do y1 in place to conserve memory
;   x1 = x0 - interpolate(dx, (x0-minx)/(max(shifts.gx)-minx)*(ngridx-1), (y0-miny)/(max(shifts.gy)-miny)*(ngridy-1),cubic=-0.5)
;   y1 = y0 - interpolate(dy, (x0-minx)/(max(shifts.gx)-minx)*(ngridx-1), (y0-miny)/(max(shifts.gy)-miny)*(ngridy-1),cubic=-0.5)
;   undefine, x0,y0
;	(*self.photimg)[0,0] = interpolate(*self.photimg, temporary(x1), temporary(y1), missing=0.0, cubic=-0.5)
;   logger, 'registering image npair:', n, 'ngrid',ngrid, 'min points:', min_points, ' method:',method, (isa(power) ? power : ''), /info
  ;             src.y+dxy_psf[1,iok], gx, gy, coefx, coefy,  $
  ;             pscale=pixscale(self.fdet), fout=self.fphot.replace('sci.fits','fit_shift.pdf'),$
  ;             sigclip=3.5, smoothing=src[0].dim[0], asize=((*self.detimg).dim)[0]/25, _extra=extra
;   regrid, src[icentroid[iok]].x, src[icentroid[iok]].y, src[icentroid[iok]].x+dxy_psf[0,iok], $
;               src[icentroid[iok]].y+dxy_psf[1,iok], gx, gy, coefx, coefy,  $
;               pscale=pixscale(self.fdet), fout=self.fphot.replace('sci.fits','fit_shift.pdf'),$
;               sigclip=3.5, smoothing=src[0].dim[0], asize=((*self.detimg).dim)[0]/25, _extra=extra

; test if also can be fitted with PCA PSF residuals
; then provides a way of mapping PSF at higher spatial resolution
; ------------- tweak fits of brightest objects with large residuals
; add additional templates for the brightest sources to model residual:
; e.g., gradients, nuclear activity, or small shifts, size
function mophongo::fit_residuals, src, scale, ifix, stopme=stopme, interp=interp, cubic=cubic
   ; common mophongo_kernel_com, basis, coef, ast, gra, gdec, gx, gy, xc, yc, kernel, fkernel

   ifix = reverse(ifix[sort(scale[ifix]/src[ifix].eflux_model)])
   logger, 'fit residuals for ',ifix.length,'objects SNR >',self.param.fit_snrhi_psf, /info

; ----- fit brightest sources with a bit more freedom: both in profile and centroid
; @@@@@ check binning issues
   Pr = [[8.0, 0.0], [0.96, 0.0]]  & Qr = [[8.0, 0.96], [0.0, 0.0]] ; expand r
   Px = [[4.0, 0.0],  [0.98, 0.0]] & Qx = [[-4.0, 1.02], [0.0, 0.0]] ; shear x
   Py = [[-4.0, 0.0], [1.02, 0.0]] & Qy = [[4.0, 0.98], [0.0, 0.0]]  ; shear y

   kdim = src[0].dim
   k4 = (kdim/4)[0]
   bin =  self.param.fit_bin
   extast, headfits(self.fdet), ast_tmpl   ; det pixscale
   psf_basis = transpose(self.getkernel(/getbasis, ast_out=ast_tmpl))
  ; nbasis = (psf_basis.dim)[0]
   nbasis = 0
   !null = growthcurve(mophongo.getkernel(1,1,ast_out=ast_tmpl),rhalf=rhalf_phot)

   ; sigmoid weighting function
   sm = lambda(x,m,s: 1.0/(1+exp(-(x-m)/s)))
   !null = apermask(kdim[0],d=rr)
   ww = 1.0 - sm(rr, kdim[0]/4.0, kdim[0]/8.0)

   ncol = 7  + nbasis
   aa = fltarr([ncol, kdim])   ; holds basis to model residuals

  ; R = extrac(identity(ncol),0,0,ncol+2,ncol)
  ; foreach i, where(R) do R[i] *= [1,-2,1]

   ; fit residuals with new basis function set
   if ifix.length gt 0 then foreach s, src[ifix],i do begin
      model = self.make_model(src, scale, id=s.id,  distance=kdim[0]/2.0, outsize=kdim, winx=winx, winy=winy,det=det)
      if bin gt 1 then tmpl = congrid(s.tmpl, kdim[0], kdim[0], cubic=cubic, interp=interp, /center)/bin^2 else tmpl=s.tmpl

      ; @@@ check resolution effects here if binning
      phot = (*self.photimg)[winx[0]:winx[1], winy[0]:winy[1]]
      ivar = (*self.photwht)[winx[0]:winx[1], winy[0]:winy[1]]
      res =  phot-model

      iid = (where(src.id eq s.id))[0]
      iiscale = scale[iid]
      clean = res + iiscale*tmpl

      clean4 = clean[k4:3*k4,k4:3*k4]
      res4 = res[k4:3*k4,k4:3*k4]
      ivar4 = ivar[k4:3*k4,k4:3*k4]
if 0 then begin
      ; @@@@  apply residual shift to all nearby templates
      restore, self.fphot.replace('sci.fits','fit_shift.sav')
      ish=where(s.id eq id[shifts.iok],nsh)
      rsh = (shifts.zfit-shifts.z)[*,ish]
      resn = phot-imshift(model,rsh,cubic=-0.5)
      faper, (res)^2*ivar, !null, !null, rhalf_phot/3.0, fres_old, /mean, os=1
      faper, (resn)^2*ivar, !null, !null, rhalf_phot/3.0, fres_new, /mean, os=1
      inn = self.overlap(src, id=s.id, distance=kdim[0]/4.0)
      logger, 'shift',  fres_old , '->', fres_new, (fres_new lt fres_old/1.1 and scale[iid] eq max(scale[inn])) ? 'YES' : ''

      if 0 and fres_new lt fres_old/1.1 and scale[iid] eq max(scale[inn]) then begin
         foreach j,inn do src[j].tmpl = imshift(src[j].tmpl,rsh/bin, interp=1)
         model = self.make_model(src, scale, id=s.id, inn=inn, distance=kdim[0]/2.0, outsize=kdim, winx=winx, winy=winy,det=det)
         res =  phot-model
         res4 = res[k4:3*k4,k4:3*k4]
       end

      if keyword_set(stopme) then begin
         if i eq 0 then window,xs=2400,ys=400
        ; tvs, phot-imshift(model,rsh,cubic=-0.5),mm=[-1,1]*3e-4
         tvs, clean - iiscale*(tmpl),mm=[-1,1]*3e-4
         tvs, resn,mm=[-1,1]*3e-4,pos=1
         stopkey
      end
end
      gal =  tmpl
      ; extra basis functions: shift x, shift y, expand r, shear x, shear, gal
      aa[0,*,*] = (shift(gal,3,0)-shift(gal,-3,0))/2.0 * ww
      aa[1,*,*] = (shift(gal,0,3)-shift(gal,0,-3))/2.0 * ww
      aa[2,*,*] = (gal-poly_2d(gal,Pr,Qr, cubic=-0.5)) * ww
      aa[3,*,*] = (gal-poly_2d(gal,Px,Qx, cubic=-0.5)) * ww
      aa[4,*,*] = (gal-poly_2d(gal,Py,Qy, cubic=-0.5)) * ww
      aa[5,*,*] =  tmpl               ; @@@ do we fit residuals, or simulatenous fit ? @@@ is the same if LLS?
      aa[6,*,*] =  self.getkernel(s.ra,s.dec,ast_out=ast_tmpl) * ww
      if nbasis gt 0 then aa[7:*,*,*] = psf_basis[1:nbasis,*,*] * rebin(reform(ww^2,[1,ww.dim]), [nbasis, kdim])

      aa4 = reform(aa[*,k4:3*k4,k4:3*k4], ncol, (3*k4-k4+1)^2)
      aat4 = transpose(aa4)
      ata4 = aat4 ## aa4
      xx = invert(ata4) ## (aat4 ## reform(clean4, 1, (3*k4-k4+1)^2) )
     ; regularized
;      alpha = median(diagonal(ata4))/1e3
 ;     xxl = invert(ata4 + alpha*(transpose(R) # R)) ## (aat4 ## reform(clean4, 1, (3*k4-k4+1)^2) )
  ;    dm = diagonal(ata4)
  ;    lam = min(dm[where(dm gt 0)])/2.0
  ;    xx = invert(ata4 + lam*identity(ncol)) ## (aat4 ## reform(clean4, 1, (3*k4-k4+1)^2) )
      lin = reform(xx # reform(aa, ncol, model.length), model.dim)
      lin4  = lin[k4:3*k4,k4:3*k4]

       if keyword_set(stopme) then begin
         if i eq 0 then window,xs=2400,ys=400
         erase
         tvs, clean4, pos=0, mm=[-1,1]*3e-4
         tvs, res[k4:3*k4,k4:3*k4], pos=1, mm=[-1,1]*3e-4
         tvs, lin4, pos=2, mm=[-1,1]*3e-4
         tvs, clean[k4:3*k4,k4:3*k4]-lin4, pos=3, mm=[-1,1]*3e-4
         tvs, (det)[k4:3*k4,k4:3*k4], pos=4, mm=[-1,1]*5e1
      end

      faper, (res4)^2*ivar4, !null, !null, rhalf_phot/3.0, fres_old, /mean, os=1
      faper, (clean4-lin4)^2*ivar4, !null, !null, rhalf_phot/3.0, fres_new, /mean, os=1
   ;   statusline, '                                tweaking fit '+s.id.tostring()+' '+fres_old.tostring()+' -> '+fres_new.tostring()+' : '+(fres_old/fres_new).tostring()+' better'
      statusline, 'tweaking fit '+s.id.tostring()+' '+fres_old.tostring()+' -> '+fres_new.tostring()+' : '+(fres_old/fres_new).tostring()+' better'

      ; only keep significant improvements @@@ should flag sources: hardwired
      if fres_new lt fres_old/2.0 then begin
         if not isa(iupdate) then iupdate = list(ifix[i]) else iupdate.add, ifix[i]
         scale[ifix[i]] = total(lin)
         s.tmpl =  rbin(lin/scale[ifix[i]],bin)    ; rescale residual back to normalized model
         src[ifix[i]] = s
      end

     if keyword_set(stopme) then begin
         modelt = self.make_model(src, scale, id=s.id, distance=kdim[0]/2.0, outsize=kdim, winx=winx, winy=winy)
         tvs, (phot-modelt)[k4:3*k4,k4:3*k4], pos=5, mm=[-1,1]*3e-4
         stopkey,/silent
       end
  end
   return, isa(iupdate) ? iupdate.toarray() : !null
end

; drivers
pro mophongo::totalphot
   compile_opt idl2

   logger, 'total magnitudes', /info
   for i=0L,obj.length-1 do begin
      od = self.obj[i]
      ; detection image

      od.seg = ptr_new(seg[od.xmin:od.xmax,od.ymin:od.ymax], /no_copy)
      od.img = ptr_new(det[od.xmin:od.xmax,od.ymin:od.ymax], /no_copy)

      ; psf matched detection -> store all parameters, totcor etc, here
      op = od
      op.img = ptr_new(img[op.xmin:op.xmax,op.ymin:op.ymax], /no_copy)

     !p.multi=[0,3,2]
      ; measure in color aperture on psf-matched detection image
      detect_kron, op, kron_factor=par.phot_kron, bias_shrink=par.bias_shrink, $
           bias_fraction=par.bias_fraction, blend_shrink=par.blend_shrink, minradius=par.phot_minradius/pscl

      ; measure in detection aperture on detection image
      detect_kron, od, kron_factor=par.detect_kron, bias_shrink=par.bias_shrink, $
                  bias_fraction=par.bias_fraction, blend_shrink=1.0, minradius=par.phot_minradius/pscl, noverlap=noverlap

      mask_shrink = sqrt(od.kron_area/(noverlap+od.kron_area))  ; correct kron ellipse for masked pixels
      faper,  detpsf, !null, !null, od.kron_major*mask_shrink, inv_det_apcor, elon=od.kron_major/od.kron_minor, theta=od.theta
      op.apcor = 1.0 / inv_det_apcor
      op.totcor = (od.flux_auto / op.flux_auto) * op.apcor

      if i mod 20 eq 0 then statusline, i.s()+'/'+obj.length.s()+'    '+str(100.0*i/obj.length)+"%"
      obj[i] = op

;      logger, '# apcor  (apply flux_auto det)    # totcor (apply flux_auto phot) '
;      logger, op.apcor,  op.totcor,   (od.flux_auto*op.apcor),'=',(op.flux_auto*op.totcor)
      detect_showstamp, op, minradius=par.phot_minradius/pscl, title='KRON='+str(par.phot_kron)
      detect_showstamp, od, minradius=par.phot_minradius/pscl, title='KRON='+str(par.detect_kron)
      stopkey
   end


end

pro mophongo::aperphot
   compile_opt idl2

; split off 1) loading of images, 2) photometry on single source

      i=6
  logger, froot[i]
;     i=8
      img = readfits(froot[i]+'_sci.fits',h,/silent,nan=0.0)
      con = readfits(froot[i]+'_con.fits',h,/silent,nan=0.0)
      wht = readfits(froot[i]+'_wht.fits',/silent,nan=0.0)
      rms2 = readfits(froot[i]+'_con_rms.fits',/silent,nan=0.0)
      rms = readfits(froot[i]+'_rms.fits',/silent,nan=0.0)

     faper, rms, obj.x, obj.y, obj.kron_major, fpix, elon=obj.kron_major/obj.kron_minor, theta=obj.theta, /status,/mean
     frms =  sqrt(obj.kron_area)*fpix
     faper, rms2, obj.x, obj.y, obj.kron_major, fpix2, elon=obj.kron_major/obj.kron_minor, theta=obj.theta, /status,/mean
     frms2 =  sqrt(obj.kron_area)*fpix
     faper, con, obj.x, obj.y, obj.kron_major, fcon, elon=obj.kron_major/obj.kron_minor, theta=obj.theta, /status
     faper, wht, obj.x, obj.y, obj.kron_major, fwht, elon=obj.kron_major/obj.kron_minor, theta=obj.theta, /status, /mean
  snr = fcon/frms  ; seems wrong
  print, fcon[10:17]
  print, fwht[10:17]
  print, obj[10:17].kron_area, obj[10:17].kron_major

print,median(sqrt(obj.kron_area/!pi)), median(sqrt(obj.kron_area))
print,median(sqrt(obj.kron_area/!pi))*0.06*2

end

function mophongo::psf, fwhm=fwhm, npixel=npixel, centroid=centroid, stopme=stopme, _extra=extra
  compile_opt  static
  os = 5
  if not keyword_set(centroid) then centroid = (npixel-1.)/2.
;   centroid_os = (centroid + 0.5)*os - 0.5
  centroid_os = centroid*os + 1.0

  ; offset error in centroid of psf gaussian? why need to add 1 to make it work?
  p =  psf_gaussian(fwhm=fwhm*os,npixel=npixel*os,centroid=centroid_os+1,_extra=extra)

 if keyword_set(stopme) then begin
  psfb = rbin(p,os)
  tvs,gauss2dfit(p,g)  & print,g
  tvs,gauss2dfit(psfb,g)  & print,g
  stopkey
end

  return, rbin(p,os)

; binned coordinates
;  xb = (x - 1)/3.0
;  x = xb * 3.0 + 1.0
end


pro mophongo::simulate, bin
    if not keyword_set(bin) then bin=1
    if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

  fname = 'gauss_sim'+(round(self.param.fit_bin)).tostring()+'_'+self.param.fit_interp+'.sav'
  if file_test(fname) then restore, fname else begin
      n = 4000L
      npix = ((*self.detimg).dim)[0]
      buf = 210
      seed = 999L
      x = randomu(seed,n)*(npix[0]-2*buf+1)+buf
      y = randomu(seed,n)*(npix[0]-2*buf+1)+buf

      ; @@@ cap at snr = 50e3, expand to 5000 sources over full frame, more sources at faintest end
      flo = sample_fx('x^(-1.3)',[0.2,100],2600,seed=seed)
      fhi = sample_fx('x^(-1.2)',[100,3e4],1400,seed=seed)
      ;    fhi = 10^(randomu(seed,800)*2.5 + 2.0)
      f = [flo,fhi]
      plothist, alog10(flo),xr=[-1,5],/ylog, bin=0.1
      plothist, alog10(fhi),xr=[-1,5],/ylog, bin=0.1
      plothist, alog10(f),xr=[-1,5],/ylog, bin=0.1
      help,where(f lt 1), where(f gt 500)
      ; 2000 sources: 500 < snr1 and 500 > snr 500
      stopkey

      dsig = 1e-8     ; some noise floor against underflows
      psig = 0.2e-1   ; this leads fo

      fwhm_hi = 4.0   ; in det
      fwhm_lo = 10.0  ; in binned coordinates -> 30
      offrot = 0.1

      extast, headfits(self.fdet), ast_det
      psf = self.getpsf(1, 1, gaussian=fwhm_hi)
      kern = self.getkernel(1, 1, gaussian=fwhm_lo, ast_out=ast_det)
      print, total(self.getpsf(1, 1))
      print, total(self.getkernel(1, 1))

      emodel = sqrt(1.0/total(kern^2))*psig
      logger, ' --------------------------------------------- '
      logger, ' VALIDATE SNR range = ', minmax(f)/emodel
      logger, ' --------------------------------------------- '

      ; create rotated positions
      kk = affine.atopq(affine.T(npix/2.,npix/2.) ## affine.R(offrot) ## affine.T(-npix/2.,-npix/2.) )
      kxy, x,y,reform(kk.p,2,2),reform(kk.q,2,2), xn,yn

      ; create gaussian random field offset positions
      rfield = randomfield([30,30])

;plot, x,y,psym=1,xr=[0,100],yr=[0,100]
;plot, xn,yn,psym=1,xr=[0,100],yr=[0,100]
    div = kern.dim
    rfieldx = randomfield((*self.detimg).dim/div,seed=seed)
    rfieldy = randomfield((*self.detimg).dim/div,seed=seed)
    xg  = x + rfieldx[round(x/div[0]),(y/div[1])]
    yg  = y + rfieldy[round(x/div[0]),(y/div[1])]

      d = fltarr(npix,npix)
      p = fltarr(npix,npix)
      pr = fltarr(npix,npix)
      pg = fltarr(npix,npix)
      tsz=75
      ksz=405
      xy = round([1#x,1#y])
      dx = [1#x,1#y] - round([1#x,1#y])
      for i=0,n-1 do begin &$
           print, i, xy[*,i], dx[*,i], f='(i,10f10.3)' &$
       ;    if i eq 18 then psf = mophongo.psf(fwhm=fwhm_hi,npixel=tsz,centroid=(tsz-[1.,1.])/2.+dx[*,i],/norm,/stopme)*f[i] &$
           psf = mophongo.psf(fwhm=fwhm_hi,npixel=tsz,centroid=(tsz-[1.,1.])/2.+dx[*,i],/norm)*f[i] &$
           d[xy[0,i]-tsz/2:xy[0,i]+tsz/2,xy[1,i]-tsz/2:xy[1,i]+tsz/2] += psf &$
           psf_sm = rbin( rbin(psf, bin), bin, /expand, cubic=cubic, interp=interp) &$   ; presmooth PSF for binning and interpolation
           lowres = fconvolve(kern,psf_sm) &$                            ; so kernel effectively deconvolved
           p[xy[0,i]-ksz/2:xy[0,i]+ksz/2,xy[1,i]-ksz/2:xy[1,i]+ksz/2] += lowres &$
          !null = check_math(mask=32) &$
           xyn = round([1#xn,1#yn])  &$   ; rotated field
           dxn = [1#xn,1#yn] - xyn &$
           psf = mophongo.psf(fwhm=fwhm_hi,npixel=tsz,centroid=(tsz-[1.,1.])/2.+dxn[*,i],/norm)*f[i] &$
           psf_sm = rbin( rbin(psf, bin), bin, /expand, cubic=cubic, interp=interp) &$   ; presmooth PSF for binning and interpolation
           lowres = fconvolve(kern,psf_sm) &$                            ; so kernel effectively deconvolved
           pr[xyn[0,i]-ksz/2:xyn[0,i]+ksz/2,xyn[1,i]-ksz/2:xyn[1,i]+ksz/2] += lowres &$
          !null = check_math(mask=32) &$
           xyg = round([1#xg,1#yg])  &$   ; gaussian field
           dxg = [1#xg,1#yg] - xyg &$
           psf = mophongo.psf(fwhm=fwhm_hi,npixel=tsz,centroid=(tsz-[1.,1.])/2.+dxg[*,i],/norm)*f[i] &$
           psf_sm = rbin( rbin(psf, bin), bin, /expand, cubic=cubic, interp=interp) &$   ; presmooth PSF for binning and interpolation
           lowres = fconvolve(kern,psf_sm) &$                            ; so kernel effectively deconvolved
           pg[xyg[0,i]-ksz/2:xyg[0,i]+ksz/2,xyg[1,i]-ksz/2:xyg[1,i]+ksz/2] += lowres &$
          !null = check_math(mask=32) &$
        end
        ; correct for pixel?
        d += randomn(seed,npix,npix)*dsig
        p += randomn(seed,npix,npix)*psig
        pr += randomn(seed,npix,npix)*psig

      (*self.detimg)[0:npix-1,0:npix-1] = d
      (*self.detwht)[0:npix-1,0:npix-1] += 1.0/dsig^2

       o = detect_objects((*self.detimg),seg=seg,detect_thresh=5*dsig,/deblend)
       o = o[where(o.use)]
       ii = match_2d(o.x, o.y, x, y, 10, m=m)
       xrms = mad(o.x-x[ii])
      ; plothist, o.x-x[ii], bin=xrms/3,col='red', xr=[-10,10]*xrms
      ; plothist, o.y-y[ii], bin=xrms/3,col='red', xr=[-10,10]*xrms

      forprint, o[ii].id, x[ii],y[ii],f[ii], textout='cat.txt',comment='# id x y f'
       x=x[ii]
       y=y[ii]
       xn=xn[ii]
       yn=yn[ii]
       xg=xg[ii]
       yg=yg[ii]
       f=f[ii]
       sbin =  (round(self.param.fit_bin)).tostring()
        save, o, x, y, xn, yn, xg, yg, f, p, pr, pg, d, seg, dsig, psig, fwhm_lo, fwhm_hi, sbin, ii ,emodel, filename=fname
   end

  npix = (d.dim)[0]
  (*self.detimg)[0:npix-1,0:npix-1] = d
  *self.detwht *= 0
  (*self.detwht)[0:npix-1,0:npix-1] += 1.0/dsig^2
  (*self.photimg)[0:npix-1,0:npix-1] = p
  *self.photwht *= 0
  (*self.photwht)[0:npix-1,0:npix-1] += 1.0/psig^2

  (*self.segmap)[0,0] = seg
  *self.obj = o

;stopkey

end

;  if n_elements(sys_err) eq 0 then sys_err=0.02 ; circular phot apertures radii in pixels ;SW
;  if not keyword_set(raper) then raper=[10] ; circular phot apertures radii in pixels ;SW
;  if not keyword_set(snrlo) then snrlo = 3. ; if source not detected at SNRlo, then remove from fit list
;  if not keyword_set(maxiter) then maxiter=20L   ; maximum iteration for mpfit
;  if not keyword_set(ftol) then ftol=1e-8       ; stop fit iteration is fractional change < ftol
;  if not keyword_set(snrhi) then snrhi=200.     ; if source brighter than [snrhi]/rms*pi*(fwhm/2)^2) it is fitted, even if outside rlim
;  if not keyword_set(masksig) then masksig=0.1  ; mask sources to down to a circularized masksig*rms isophote
;  if not keyword_set(maskrmin) then maskrmin = 3 ; minimum radius of mask if source is masked
;  if n_elements(maxshift) eq 0 then maxshift=3.   ; maximum global shift in [x,y] allowed [pixels]
;  if not keyword_set(osample) then osample=1.    ;for convenience: corrects the rms and chi2 for oversampling factor
;  if not keyword_set(nsigma) then nsig=5. else nsig = nsigma > 1
;  psf_apercor = keyword_set(psf_apercor)         ; if set, calculate the aperture corrections from the PSFs, not the best-fit models
;  if not keyword_set(osample) then osample=1.    ;for convenience: corrects the rms and chi2 for oversampling factor
;  if n_elements(display) eq 0 then display = 0.                 ; display diagnostic images to screen? value set is scaling in rms
;  if not keyword_set(libnative) then libnative=''
;  savefits = keyword_set(savefits)               ; save all fits tiles used in the analysis?
;  verbose = keyword_set(silent) eq 0
;  badval = 0.
;  id = id[0]                  ; avoid single element array
; @@@ kernel and all PSFs are assumed to be perfectly centerered
pro mophongo::fitphot_validate_all
  logger, 'VALIDATE ALL '
  self.fitphot_validate
;  self.fitphot_validate,   5.0
;  self.fitphot_validate,  50.0
;  self.fitphot_validate, 500.0
end

pro mophongo::fitphot_validate, snrlim
   compile_opt idl2

    if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

   ; @@@ check for existence of phot,det,and objects
   if ~isa(self) then return

   ; @@@ should clean up section below

   extast, headfits(self.fdet), adet
   getrot,adet,pa,pscl
   if ((*self.obj).ra)[0] eq 0.0 then begin
      xy2ad, (*self.obj).x, (*self.obj).y, adet, ra, dec
      (*self.obj).ra = ra
      (*self.obj).dec = dec
   end

;  @@@ get a typical kernel for some approximate information
   mra = median((*self.obj).ra)
   mdec = median((*self.obj).dec)
   raper = range(1,202,100,/log)
   gckern= growthcurve(self.getkernel(mra, mdec, ast_kern=akern,ast_out=adet), raper=raper, rhalf=rhalf_phot)
   gcpsf = growthcurve(self.getpsf(mra,mdec),rhalf=rhalf_det)
   self.param.rhalf_phot = rhalf_phot
   self.param.rhalf_det = rhalf_det

   ; auto determine binning applied to modeling if binning < 1
   if self.param.fit_bin lt 1 then self.param.fit_bin = oddsize(floor(rhalf_phot/5.0))  ; @@@ test even
;   self.param.fit_bin = 1    ; @@@ hardcoded
   bin =  self.param.fit_bin
   logger, 'binning model by ', bin, ' to ',  3600*pscl[1]*bin,'"/pix', /info

   ; simulated gaussian sources w/ gaussian noise
   self.simulate, self.param.fit_bin

; ----------------------------- load simulated images
; ------ generate templates  bulk ~50% of time
   ; isolate objects in template det_img and convolve with kernel to match phot_img
   restore, 'gauss_sim'+(round(self.param.fit_bin)).tostring()+'_'+self.param.fit_interp+'.sav'
   extast, headfits(self.fdet), ast_det
   psf = self.getpsf(1, 1, gaussian=fwhm_hi)
   kern = self.getkernel(1, 1, gaussian=fwhm_lo, ast_out=ast_det,bin=bin)
   ast_det.cd *= self.param.fit_bin
   kern = self.getkernel(1, 1, ast_out=ast_det, bin=bin)

   if not keyword_set(snrlim) then begin
      snrlim = min(f)/emodel
      logger, ' --------------------------------------------- '
      logger, ' VALIDATE SNR range = ', minmax(f)/emodel
      logger, ' --------------------------------------------- '
   end else begin
      ; addrms = 1e-2   ; this goes to SNR=1
      ;addrms = 2e-2/snrlim     ; to SNR=5 etc
      ;logger, 'adding rms of ', addrms
      ;(*self.photimg)[0,0] = (*self.photimg) +  randomn(seed,(*self.photimg).dim)*addrms
      ;var = (*self.photwht ne 0)/(*self.photwht + (*self.photwht eq 0))
      ;(*self.photwht)[0,0] = (*self.photwht ne 0)/((addrms)^2 + var)
      stopkey
   end
; ----------------------------- load simulated images
;  (*self.photimg)[0,0] =  p
;  (*self.photimg)[0,0] =  pg
  (*self.photimg)[0,0] =  pg

   self.param.fit_fast = 1   ; calculate everything in binned ?
   src = self.make_tmpl(*self.obj)     ; stored in self.tmpl
   self.make_normal, src, ata, atb, noisefloor=0.1

   logger, 'sparsity normal matrix:', ata.nnz/product(ata.shape.toarray())
   logger, 'solving linear system', /info
   scale0 = self.solve(src, ata, atb, regul_neg=2)
   model0 = ( junk = self.make_model(src, scale0 > 0, residual=residual0) )  ; forces copy rather than memmap
   src.flux_model = scale0

    ;phot =  shift(rbin(photbin,bin,/expand,cubic=cubic,interp=interp),1,1)
   if self.param.fit_fast and bin gt 1 then phot = rbin(shift((*self.photimg),-1,-1),3) else phot = shmvar('phot')
   det = shmvar('det')

   snrs = '_snrlim'+(round(snrlim)).tostring()
   sbin = bin.tostring()
   snr = scale0/src.eflux_model

   file_mkdir, 'work/gauss_bin'+sbin
   cleanplot
   loadct,0,/silent
   cgps_open, 'img'+snrs+'.pdf',/encaps,xs=10,ys=5,/nomatch
   cgimage, phot,/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,1]
   cgimage, det, keep,/stret,minv=-5e-2,maxv=5e-2, layout=[2,1,2]
   cgps_close
   file_move, 'img'+snrs+'.pdf', 'work/gauss_bin'+sbin+'/img'+snrs+'_'+self.param.fit_interp+'.pdf',/over

   cgps_open, 'img_sub'+snrs+'.pdf',/encaps,xs=10,ys=5,/nomatch
   cgimage, residual0,/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,1]
   cgimage, model0,  /keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,2]
   cgps_close
   file_move, 'img_sub'+snrs+'.pdf', 'work/gauss_bin'+sbin+'/img_sub'+snrs+'_'+self.param.fit_interp+'.pdf',/over

   msig =  median(src.eflux_model)
   xf =findgen(100,start=min(f))*(max(f)-min(f))/100.
   x = range(min(f)/10.,max(f)*10.,100,/log)
   y = src.eflux_model/x
   nkern = 1.0/total(kern^2)
   sf = sort(f)
   ifaint = sf[0:500]
   ibright = sf[-500:-1]
   sfaint = mad(((f-scale0)/f)[ifaint])
   sbright = mad(((f-scale0)/f)[ibright])

   nsig = 5
   snr_mod = f/src.eflux_model
   cgps_open, 'phot'+snrs+'.pdf', xs=15,ys=14, /encaps
   cgerase
   cgplot, f/src.eflux_model, (scale0-f)/f > (-nsig*sfaint) < (nsig*sfaint), psym=16,symsize=0.4, $
      yr=[-1,1]*(nsig+1)*sfaint,/xlog, xr=min(snr_mod)*[0.9,1000], layout=[2,2,1], ytitle='(f_mp - f_true)/f_true', xtitle='snr'
   cgplot, x/src.eflux_model, y, col='red',/over, thick=5,linest=2
   cgplot, x/src.eflux_model, -y, col='red',/over, thick=5,linest=2
   hline, 0, col='darkgray',xr=[0.1,1e6],linest=2,thick=5
   plothist, ((scale0-f)/f)[ifaint] ,/ylog,xr=[-1,1]*(nsig/1.5)*sfaint,col='red', bin=sfaint/10, layout=[2,2,2]

   cgplot, f/src.eflux_model, (scale0-f)/f > (-0.098) < 0.098, psym=16,symsize=0.4, $
      xr=max(snr_mod)*[2.9e-3,1], yr=[-1,1]*((nsig+1)*sbright > 0.05),/xlog, layout=[2,2,3], ytitle='(f_mp - f_true)/f_true', xtitle='snr'
   cgplot, x/src.eflux_model, y, col='red',/over, thick=5,linest=2
   cgplot, x/src.eflux_model, -y, col='red',/over, thick=5,linest=2
   hline, 0, col='darkgray',xr=[0.1,1e6],linest=2,thick=5
   plothist, ((scale0-f)/f)[ibright] ,/ylog,xr=[-1,1]*((nsig/1.5)*sbright > 0.02),col='red', bin=sbright/3, layout=[2,2,4]
   cgps_close
   file_move,'phot'+snrs+'.pdf', 'work/gauss_bin'+sbin+'/phot'+snrs+'_'+self.param.fit_interp+'.pdf',/over

report_memory
photorig = *self.photimg

;  cgimage,(rbin(shift(*self.photimg,-1,-1),3))-model0,/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,1]
if 0 then begin
  ; @@@@ need to validate on input list!!
   self.param.register_snrlim = 500
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=1, min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=2)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=3, min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=4, min_points=20)     ;  ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=3, min_points=10)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=3, min_points=10,smoothin=400)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)

; always do 2step: 1) 1st degree polynomial (alignment) 2) kriging on residuals (which are now de-trended)

;NUGGET: When the data to be fit includes noise, the Gaussian process model
;can be used by specifying the variance of the noise for each point.
;GaussianProcess takes a parameter nugget which is added to the
;diagonal of the correlation matrix between training points: in general
;this is a type of Tikhonov regularization. In the special case of a
;squared-exponential correlation function, this normalization is
;equivalent to specifying a fractional variance in the input. That is
; MODEL:
;Common correlation models matches some famous SVM’s kernels because
;they are mostly built on equivalent assumptions. They must fulfill
;Mercer’s conditions and should additionally remain stationary. Note
;however, that the choice of the correlation model should be made in
;agreement with the known properties of the original experiment from
;which the observations come. For instance:
;If the original experiment is known to be infinitely differentiable
;(smooth), then one should use the squared-exponential correlation
;model.
;If it’s not, then one should rather use the exponential correlation
;model.
;Note also that there exists a correlation model that takes the degree
;of derivability as input: this is the Matern correlation model, but
;it’s not implemented here (TODO).
   dxy =  self.centroid( src, scale0, /test, method='Kriging', min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,500,0,1e-4],min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,500,0,1e-4],min_points=50)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,400,0,1e-4],min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,400],min_points=20)      ; ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
  ; measurement error ~5e-3, local intrinsic rms~ 0.02 ->  nugget 3e-5, scale 4e-4
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,400,3e-5,4e-4],min_points=20)    ; ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,400,1e-5],min_points=20)         ; ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok

   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[1,400,0,1e-4],min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[3,400,0,1e-4],min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[4,400,0,1e-4],min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok

   dxy =  self.centroid( src, scale0, /test, method='ModifiedShepards')
   dxy =  self.centroid( src, scale0, /test, method='ModifiedShepards', neighbor=[5,20])
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='ModifiedShepards', neighbor=[11,20])
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='ModifiedShepards', neighbor=[15,30])
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='PolynomialRegression',power=1)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='PolynomialRegression',power=2, min_points=20)    ;  ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)
   dxy =  self.centroid( src, scale0, /test, method='PolynomialRegression',power=3)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='linear')                                    ; very well internally, but bad at edges, shoulders histogram
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='quintic')                                    ;  worse than linear
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='NearestNeighbor')                          ;  best ok, if 1 is wrong -> bomb
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='NaturalNeighbor')
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='RadialBasisFunction')
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok
   dxy =  self.centroid( src, scale0, /test, method='RadialBasisFunction', function_type=4, min_points=20)
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2), nok

   self.param.fit_shift_sigclip=3.0
   self.param.register_snrlim = 50
   dxy =  self.centroid( src, scale0, /test, method='Kriging', variogram=[2,400,1e-4],min_points=20)         ; ok
    print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0,nok)],dim=2),nok
   dxy =  self.centroid( src, scale0, /test, method='InverseDistance', power=4, min_points=20)     ;  ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2),nok
    dxy =  self.centroid( src, scale0, /test, method='PolynomialRegression',power=2, min_points=20)    ;  ok
   print,median(dxy[*,where(dxy[0,*] ne 0)],dim=2), mad(dxy[*,where(dxy[0,*] ne 0)],dim=2)

end

; *self.photimg[0,0] = photorig
;   src = self.make_tmpl(*self.obj)     ; stored in self.tmpl
;   self.make_normal, src, ata, atb, noisefloor=0.1

;  ----- centroid on brightish sources  ----- ----- ----- ----- ----- -----
; @@@ keep inv distance for now: still small number of sources with large residuals -> fix separately
; @@@strong residual for small number of sources left (~100 bright) probabl confusion
; @@@ TODO: make comparison to true shift plot both for HST as IRAC gauss sim.plot  dx,dy for  for good and bad residuals !
; @@@ make plot with sources with no neighbours
; @@@ put kriging + parameters in param file
; @@@ regulation too string? photometry too tight?
; @@@ then move on!!!

   self.param.register_snrlim = 100
;   dxy =  self.centroid( src, scale0, method='PolynomialRegression', variogram=[2,400],min_points=20,/usefit)         ; ok
; dxy =  self.centroid( src, scale0, method='Kriging', variogram=[2,200], min_points=9, density=0.6)         ; ok
; dxy =  self.centroid( src, scale0, method='Linear', min_points=21, density=0.5,smoothing=src[0].dim[0]/2)         ; ok
 ; dxy =  self.centroid( src, scale0, method='NearestNeighbor', min_points=21, density=0.5,smoothing=src[0].dim[0]/2)         ; ok
   dxy =  self.centroid( src, scale0, method='InverseDistance',  min_points=9, power=3,  density=0.6)         ; ok
    iok = where(dxy[0,*] ne 0, nok)
   print,median(dxy[*,iok],dim=2), mad(dxy[*,iok],dim=2)
   file_move, 'work/GREATS_GOODS-S_CH1_v1.2_fit_shift.pdf', 'work/gauss_bin'+sbin+'/GREATS_GOODS-S_CH1_v1.2_fit_shift'+snrs+'_'+self.param.fit_interp+'_v0.pdf',/over
   file_move, 'work/GREATS_GOODS-S_CH1_v1.2_fit_shift.cat', 'work/gauss_bin'+sbin+'/GREATS_GOODS-S_CH1_v1.2_fit_shift'+snrs+'_'+self.param.fit_interp+'.cat', /over

   mtmp = self.make_model(src, scale0>0)
   model0b = mtmp
   loadct,0
   cgimage, (det),/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[1,1,1]
   cgimage, (phot),/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[1,1,1]
   cgimage, (phot-model0b),/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[1,1,1]

   self.make_normal, src, ata, atb, noisefloor=0.1
   scale1 = self.solve(src, ata, atb, regul_neg=2, regul_res=1)
   mm = self.make_model(src, scale1>0)
   model1 = mm
   src.flux_model = scale1

   triangulate, src.x, src.y, tr, ib, c=ri
   nn_dxy = fltarr(4,(src.x).length-1)
   cgplot, [0],xr=[0,5200],yr=[0,5200]
   cgplot, src[b].x, src[b].y, /over, psym=-16,col='gray'
   for i=0,nn_dxy.length-1 do begin &$
      ir = cgReverseIndices(ri, i, count=n)  &$
     if n gt 3 then  nn_dxy[*,i] = [median(src[ir].model_dxy,dim=2),  mad(src[ir].model_dxy,dim=2) ]   &$
     ; if n gt 3 then ms_dr[*,i] = [mad( sqrt( total(( src[ir].model_dxy-rebin(src[i].model_dxy,2,ir.length) )^2,1) )), median(src[ir].x),median(src[ir].y)]  &$
   end
;   cgplot, src[i].x, src[i].y, /overplot,psym=16, col='red'  &$
;   cgplot, src[ir].x, src[ir].y, /overplot,psym=9,col='green'  &$
;   cgplot, src[ib].x, src[ib].y, /overplot,psym=9,symsize=1.5,col='gray'  &$
; ;  stopkey  &$
;   cgplot, src[ir].x, src[ir].y, /overplot,psym=16,symsize=1.5,col='white'  &$
;   cgplot, src[ir].x, src[ir].y, /overplot,psym=3 &$

  faper, (phot-model1)^2, (src.x-1)/bin, (src.y-1)/bin, self.param.rhalf_phot/bin, fres
   is = (reverse(sort(fres)))[0:120]
 ;  is = (sort(fres))[0:120]
   print, [1#src[is].id,1#src[is].x,1#src[is].y,1#fres[is],1#snr[is],src[is].model_dxy,nn_dxy[*,is]]

   window,2, xs=1200,ys=1200
   cgimage, phot-model1,  /keep,/stret,minv=-5e-1,maxv=5e-1, layout=[1,1,1],xr=[0,5250],yr=[0,5250]
   cgplot, 1#src[is].x,1#src[is].y, psym=9,/overplot,col='red'
   cgtext, 1#src[is].x,1#src[is].y, src[is].id.tostring(),col='red'
;
; ------- end testing shift
 stop
; dxy =  self.centroid(src, index=is, method='Kriging', variogram=[2,400], min_points=21, density=0.5, /test,/stopme,rlim=150,/usefit )
; stop

   cleanplot
   loadct,0,/silent
   cgps_open, 'img_centroid'+snrs+'.pdf',/encaps,xs=10,ys=5,/nomatch
   cgimage, (phot-model1),/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,1]
   cgimage,(model1-model0),  /keep,/stret,minv=-5e-1,maxv=5e-1, layout=[2,1,2]
   cgps_close
   file_move, 'img_centroid'+snrs+'.pdf', 'work/gauss_bin'+sbin+'/img_sub'+snrs+'_centroid_'+self.param.fit_interp+'.pdf',/over

   nsig = 5
   snr_mod = f/src.eflux_model
   cgps_open, 'phot'+snrs+'.pdf', xs=15,ys=14, /encaps
   cgerase
   cgplot, f/src.eflux_model, (scale1-f)/f > (-nsig*sfaint) < (nsig*sfaint), psym=16,symsize=0.4, $
      yr=[-1,1]*(nsig+1)*sfaint,/xlog, xr=min(snr_mod)*[0.9,1000], layout=[2,2,1], ytitle='(f_mp - f_true)/f_true', xtitle='snr'
   cgplot, x/src.eflux_model, y, col='red',/over, thick=5,linest=2
   cgplot, x/src.eflux_model, -y, col='red',/over, thick=5,linest=2
   hline, 0, col='darkgray',xr=[0.1,1e6],linest=2,thick=5
   plothist, ((scale1-f)/f)[ifaint] ,/ylog,xr=[-1,1]*(nsig/1.5)*sfaint,col='red', bin=sfaint/10, layout=[2,2,2]

   cgplot, f/src.eflux_model, (scale1-f)/f > (-0.098) < 0.098, psym=16,symsize=0.4, $
      xr=max(snr_mod)*[2.9e-3,1], yr=[-1,1]*((nsig+1)*sbright > 0.1),/xlog, layout=[2,2,3], ytitle='(f_mp - f_true)/f_true', xtitle='snr'
   cgplot, x/src.eflux_model, y, col='red',/over, thick=5,linest=2
   cgplot, x/src.eflux_model, -y, col='red',/over, thick=5,linest=2
   hline, 0, col='darkgray',xr=[0.1,1e6],linest=2,thick=5
   plothist, ((scale1-f)/f)[ibright] ,/ylog,xr=[-1,1]*((nsig/3.0)*sbright > 0.02),col='red', bin=sbright/3, layout=[2,2,4]
   cgps_close
   file_move,'phot'+snrs+'.pdf', 'work/gauss_bin'+sbin+'/phot'+snrs+'_centroid_'+self.param.fit_interp+'.pdf',/over

;  ----- centroid on brightish sources
   dxy =  self.centroid( src, scale1, /test)
   iok = where(dxy[0,*] ne 0, nok)
   print,median(dxy[*,iok],dim=2), mad(dxy[*,iok],dim=2)
   file_move, 'work/GREATS_GOODS-S_CH1_v1.2_fit_shift.pdf', 'work/gauss_bin'+sbin+'/GREATS_GOODS-S_CH1_v1.2_fit_shift'+snrs+'_'+self.param.fit_interp+'_v1.pdf',/over


   self.make_normal, src, ata, atb, noisefloor=0.1
   scale2 = self.solve(src, ata, atb, regul_neg=2,regul_res=2)
   model2 = self.make_model(src, scale2>0)
   src.flux_model = scale2
   loadct,0
   cgimage, (phot-model2),/keep,/stret,minv=-5e-1,maxv=5e-1, layout=[1,1,1]

 ;  phot1 = *self.photimg
 ;  model1 = self.make_model(src, scale>0, residual=residual)

; @@@ add matched filter photometry

stop

  shmunmap, 'objects'
  undefine, src
return

stop
stop
 ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  -----
 ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  -----
 ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  ----- ;  -----
(*self.photimg)[0,0] = phot0
help,*self.photimg

 scale = self.solve(src, ata, atb, regul_neg=2,regul_res=2)
   model = self.make_model(src, scale>0, residual=residual)
   model = self.make_model(src, scale/1.005>0, residual=residual)
   loadct,0
cgimage, (*self.photimg-model)[0:3000,0:3000],/keep,/stret,minv=-0.5e-3,maxv=0.5e-3, layout=[1,1,1]
cgimage, (smooth(*self.photimg,3)-model)[0:3000,0:3000],/keep,/stret,minv=-0.5e-3,maxv=0.5e-3, layout=[1,1,1]


; ----- subtract background from residual map
   self.background, src, scale > 0.0

; @@@ test flux measurements post backgroudn

    atb = self.make_RHS(src, interp=1)
    scale = self.solve(src, ata, atb, regul_neg=2,regul_res=2,interp=1)

; !!! ok -> hi res model is exactly the same
;self.param.fit_fast= 0
;src = self.make_tmpl(*self.obj )     ; stored in self.tmpl
;src0 = src
;self.make_normal, src0, ata0, atb0, /verbos, interp=interp, noisefloor=0.05
;scale0 = self.solve(src0[0:100], ata0, atb0, regul_neg=2, interp=interp)
;model = self.make_model(src0, scale0>0, interp=interp)
;model0 = model
;tvs, ((*self.photimg) )[0:3800,0:3800],mm=[-1,1]*1e-1
;tvs, ((*self.photimg)-model0)[0:3800,0:3800],mm=[-1,1]*1e-1
;stop
;i=where(scale0 gt 100)
;print,median(scaleb[i]/scale0[i]),mad(scaleb[i]/scale0[i])
;cgplot, scale0[i], scale0[i]/scaleb[i], psym=16,syms=0.3,/xlog,yr=[0.95,1.05]

   model = self.make_model(src, scale>0, residual=residual,interp=interp)
   i=644
   ;IDL> print,(reverse(sort(f)))[0:5]
   ;         532         644          33         302         429         129
   ;  src[i].tmpl
   print,src[i].x,src[i].y
   print, src[i].xmin, src[i].xmax, src[i].ymin, src[i].ymax
   pp = (*self.photimg)[src[i].xmin:src[i].xmax, src[i].ymin:src[i].ymax]
   ;pp = smooth(pp,7)
   tvs,(*self.photimg)-imshift(model,0.1,0.1)
   tvs, pp-model[src[i].xmin:src[i].xmax, src[i].ymin:src[i].ymax]
   tvs, pp-imshift(model[src[i].xmin:src[i].xmax, src[i].ymin:src[i].ymax],0.1,0.1)
   ; print,dxy[*,644]
   ; 0.000367564  0.000291599

   ;phot =  *self.photimg
   ;(*self.photimg)[0,0] = imshift(*self.photimg,-0.21,0.23,cubic=-0.5)

stop

; ------------- fit again with improved photometry + background
; @@@ note we can save the 'regularization' in a difference matrix/vector and add it back in when background etc is updated  -> means fewer iterations necessary?
   logger, 'second pass solve: improved astrometry + background', /info
   scale = self.solve(src, ata, atb, regul_neg=2, regul_res=2, fsig=fsig, fres=fres, residual=residual, stopme=stopme,interp=interp)

; ----- model residuals, return indices of sources updated
   fchi = (fres/fsig)^2
   ifix = where(scale/src.eflux_model gt self.param.fit_snrhi_psf and fchi gt 3.0*median(fchi))
   iupdate  = self.fit_residuals(src, scale, ifix, interp=interp)
   self.make_normal, src, ata, atb, update=iupdate, interp=interp

; ----------------------------------------
   logger, 'final solve linear system', /info
   scale = self.solve(src, ata, atb, regul_neg=2, regul_res=3, model=model, residual=residual, fsig=fsig, fres=fres,interp=interp)
   var =  1.0/(*self.photwht)  + (self.param.fit_syserr*model)^2

   ptoc

  ; loadct,0,/silent
 ;  cgimage, (residual/sqrt(var))[1800:3800,1500:3500], layout=[1,1,1],/keep,/stret,minv=-2,maxv=2
;cgimage, (residual)[1800:3500,400:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4

end


pro mophongo::fitphot
   compile_opt idl2
    if self.param.fit_interp eq 'cubic' then cubic=-0.5 else interp=1

   self.fitphot_validate_all
stop

   ptic
   ; @@@ check for existence of phot,det,and objects
   if ~isa(self) then return


   extast, headfits(self.fdet), adet
   getrot,adet,pa,pscl
   if ((*self.obj).ra)[0] eq 0.0 then begin
      xy2ad, (*self.obj).x, (*self.obj).y, adet, ra, dec
      (*self.obj).ra = ra
      (*self.obj).dec = dec
   end

;  @@@ get a typical kernel for some approximate information
   mra = median((*self.obj).ra)
   mdec = median((*self.obj).dec)
   gckern= growthcurve(self.getkernel(mra, mdec, ast_kern=akern,ast_out=adet), rhalf=rhalf_phot)
   gcpsf = growthcurve(self.getpsf(mra,mdec),rhalf=rhalf_det)
   self.param.rhalf_phot = rhalf_phot
   self.param.rhalf_det = rhalf_det

   ; auto determine binning applied to modeling if binning < 1
   if self.param.fit_bin lt 1 then self.param.fit_bin = oddsize(rhalf_phot/5.0)  ; @@@ test even
 ; self.param.fit_bin = 3     ; @@@ hardcoded
  self.param.fit_bin =1    ; @@@ hardcoded
   logger, 'binning model by ', self.param.fit_bin, ' to ',  3600*pscl[1]*self.param.fit_bin,'"/pix', /info

interp=1
; ------ generate templates  bulk ~50% of time
; id=7308
;  id = lindgen(10)+100
   ; isolate objects in template det_img and convolve with kernel to match phot_img

   src = self.make_tmpl(*self.obj )     ; stored in self.tmpl
;   ; -> AT.A = AT.b  where aij is dot product of tmpl_i src and tmpl_j and y = AT.b = tmpl_i * phot_i
   self.make_normal, src, ata, atb, noisefloor=0.1, interp=1 , /verbose

   logger, 'sparsity normal matrix:', ata.nnz/product(ata.shape.toarray())

   ; ------ solving first time....
   logger, 'solving linear system', /info
   scale = self.solve(src, ata, atb, regul_neg=2, interp=interp)

if 0 then begin
     extast, headfits(self.fdet), ast_det
     la = python.import('scipy.sparse.linalg')
   scale = (la.cg(ata.tocsr(), atb, tol=self.param.fit_tol))[0]

   aa=ata.todense()
   model = self.make_model(src, scale>0, residual=residual,interp=interp)
   loadct,0
   window,xs=1100,ys=800
   cgimage, (*self.photimg)[0:4000,0:4000], layout=[1,1,1],/keep,/stret,minv=-2e-3,maxv=2e-3
   cgimage, (model)[0:4000,0:4000], layout=[1,1,1],/keep,/stret,minv=-2e-3,maxv=2e-3
   cgimage, (residual)[0:4000,0:4000], layout=[1,1,1],/keep,/stret,minv=-2e-3,maxv=2e-3
   cgimage, (*self.detimg)[0:4000,0:4000], layout=[1,1,1],/keep,/stret,minv=-2e-3,maxv=2e-3

   cgimage, (*self.photimg)[1500:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (model)[1500:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (residual)[1500:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (residual)[1500:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4

      cgimage, (*self.photimg-*self.detimg*1000)[0:1000,0:1000], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
end


; ----- subtract background from residual map -> force fits non-negative
   self.background, src, scale > 0.0, interp=interp, /stopme

;  ----- centroid on brightish sources
   self.centroid, src, scale, interp=interp,/stopme
   atb = self.make_RHS(src, interp=interp)

; ------------- fit again with improved photometry + background
; @@@ note we can save the 'regularization' in a difference matrix/vector and add it back in when background etc is updated  -> means fewer iterations necessary?
   logger, 'second pass solve: improved astrometry + background', /info
   scale = self.solve(src, ata, atb, regul_neg=2, regul_res=2, fsig=fsig, fres=fres, residual=residual, stopme=stopme,interp=interp)

; ----- model residuals, return indices of sources updated
   fchi = (fres/fsig)^2
   ifix = where(scale/src.eflux_model gt self.param.fit_snrhi_psf and fchi gt 3.0*median(fchi))
   iupdate  = self.fit_residuals(src, scale, ifix, interp=interp)
   self.make_normal, src, ata, atb, update=iupdate, interp=interp

; ----------------------------------------
   logger, 'final solve linear system', /info
   scale = self.solve(src, ata, atb, regul_neg=2, regul_res=3, model=model, residual=residual, fsig=fsig, fres=fres,interp=interp)
   var =  1.0/(*self.photwht)  + (self.param.fit_syserr*model)^2

   ptoc

   loadct,0,/silent
   window,xs=1000,ys=1000
 ;  cgimage, (residual/sqrt(var))[1800:3800,1500:3500], layout=[1,1,1],/keep,/stret,minv=-2,maxv=2
cgimage, (residual)[1800:3500,400:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4

   cleanplot
   loadct,0,/silent
   cgWindow_SetDefs, /PS_Encapsulated, aspect=1.0, IM_Width=(residual.dim)[0]/3.0
   cgimage, (*self.photimg), layout=[1,1,1],/keep,/stretc,minv=-2e-4,maxv=2e-4, outfile='mp_img.png', output='png'
   cgimage, (model), layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4, outfile='mp_mod.png', output='png'
   cgimage, (residual) , layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4, outfile='mp_res.png', output='png'
   cgimage, (residual/sqrt(var)) , layout=[1,1,1],/keep,/stretc,minv=-3,maxv=3, outfile='mp_snr.png', output='png'
   cgimage, (*self.detimg), layout=[1,1,1],/keep,/stretc,minv=-2e1,maxv=2e1, outfile='mp_det.png', output='png'

stop

   loadct,0,/silent
   window,xs=1000,ys=1000
   cgimage, (residual/sqrt(var))[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2,maxv=2

   la = python.import('scipy.sparse.linalg')
   scale_free = (la.cg(ata, atb, tol=self.param.fit_tol))[0]

   if 0 then begin
      faper, residual, src.x, src.y, rhalf_phot/3.0, fres, os=1
      cleanplot
      !p.multi=[0,2,2]
      histogauss, fres, gr, xr=[-6,6]*1e-3;, /noplot
      histogauss, fres/fsig > (-5), gs, xr=[-6,6] ; , /noplot
      histogauss, scale_free > (-5), gs; , /noplot
      histogauss, scale_free/src.eflux_model > (-5), gs, xr=[-10,10] ; , /noplot

   ; background issues
      model = self.make_model(src, scale_free, residual=residual_free)
      faper, residual_free, src.x, src.y, rhalf_phot/3.0, fres_free, os=1

      cleanplot
      !p.multi=[0,2,2]
      cgplothist, scale_free/src.eflux_model > (-5), bin=0.2,  xr=[-6,8]
      histogauss, fres_free/fsig > (-5), gs, xr=[-6,8],  title='scale free '  ; , /noplot
      cgplothist, (scale>0)/src.eflux_model > (-15), bin=0.05,  xr=[-6,8]
      histogauss, fres/fsig > (-5), gs, xr=[-6,6] , title=' non-negative '
   end

;   cgplothist, (fres/fsig) > (-7) < 7, bin=0.1, xr=[-8,8]
   print, minmax(fres/fsig)
   help, where(fres/fsig gt 3)
   help, where(fres/fsig lt -3),  where(fres/fsig lt -5), where(fres/fsig lt -10)

   snr = scale_free/src.eflux_model
   print,minmax(snr)
   help, where(snr gt 3)
   help, where(snr lt -3),  where(snr lt -5), where(snr lt -10)

   print, 'total: '
   report_memory

   forprint, lindgen(scale.length), scale, textout='scale.txt', /nocomment

; @@@ normal equations at 0.06x binning is random phase ?  -> should interpolate, use poly2d
; when interpolate we can do 3x binning

; calc covariance matrix -> use cholesky, quick solver after factoring
;cov = aa*0
;bi = [1,fltarr(atb.length-1)]
;for i=0,atb.length-1 do cov[*,i] = (la.cg(ata, shift(bi,i), tol=self.param.fit_tol))[0]
;tvs, aai, mm=[-1,1]*1e-5
;tvs, cov, mm=[-1,1]*1e-5

; @@@@ simplify by remembering regularization ?
; @@@ simple deblending ?
; @@@ color info ?
; decide on residual -> choice, nonnegative, or regularized
; calc bandmatched filter

   loadct,0,/silent
   model = self.make_model(src, scale, residual=residual)
   modelnn = self.make_model(src, scale>0, residual=residualnn)
   cgimage, (residualnn)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-1e-4,maxv=1e-4
   cgimage, (residual)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-1e-4,maxv=1e-4
   cgimage, (modelnn)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-1e-4,maxv=1e-4
   cgimage, (model)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-1e-4,maxv=1e-4
   cgplothist, scale/src.eflux_model,bin=0.1,xrange=[-5,5]

   cgimage, (residual) , layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (residual)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (model)[1800:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4

   loadct,0,/silent
   cgimage, (*self.photimg)[800:4500,300:2600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (model)[800:4500,300:2600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (residual)[800:4500,300:2600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4
   cgimage, (residual/sqrt(var))[800:4500,300:2600], layout=[1,1,1],/keep,/stret,minv=-2,maxv=2

   cleanplot
   loadct,0,/silent
   cgWindow_SetDefs, /PS_Encapsulated, aspect=1, IM_Width=(residual.dim)[0]/3.0
  ; cgWindow_SetDefs, /PS_Encapsulated, aspect=1, IM_density=200
   cgimage, (*self.photimg), layout=[1,1,1],/keep,/stretc,minv=-2e-4,maxv=2e-4, outfile='mp_img.png', output='png'
   cgimage, (model), layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4, outfile='mp_mod.png', output='png'
   cgimage, (residual) , layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4, outfile='mp_res.png', output='png'
   cgimage, (residual/sqrt(var)) , layout=[1,1,1],/keep,/stretc,minv=-3,maxv=3, outfile='mp_snr.png', output='png'
   cgimage, (*self.detimg), layout=[1,1,1],/keep,/stretc,minv=-2e1,maxv=2e1, outfile='mp_det.png', output='png'

stop
; 718  129.60115
end
  ;aa=ata.todense()
   ;print, aa[0:5,0:1]
   ;print, atb[0:5]
   ;print,scale[0:5]
   ;print,scale[0:5]/src[0:5].eflux_model
;   la = python.import('scipy.sparse.linalg')
;   scale = (la.cg(ata, atb, tol=self.param.fit_tol))[0]
;   loadct,0,/silent
;   model = self.make_model(src, scale>0, residual=residual)
;   cgimage, (residual)[1500:3500,300:1600], layout=[1,1,1],/keep,/stret,minv=-2e-4,maxv=2e-4

;   ; test 1: read bin3 (same kernel) and expand to full resolution, make normal and continue
;if 0 then begin
; ;  ata_bin3 = ata
; ;  atb_bin3 = atb
;   src_bin3 = src
;   self.load, src, filename='udfall_fullres'
;
;   src.tmpl=0.0
;   for i=0,src.length-1 do src[i].tmpl = rbin(src_bin3[i].tmpl, /expand, 3, cubic=-0.5)
;   self.param.fit_bin=1
;
;   self.make_normal, src, ata, atb, noise=0.1
;end

;----------  threshold sparse matrix on fraction of diagional (dot product w/self)
;print,' nnz before ', ata.nnz
;   dm = (ata.diagonal()).median()
;   ata = ata.multiply(ata gt dm*self.param.fit_sparse_threshold)
;print,' nnz after ', ata.nnz

;   bbt = bb.multiply(bb gt dm*self.param.fit_sparse_threshold*10)
; tic &  bu = la.splu(bb, permc_spec='MMD_AT_PLUS_A')   & toc   ; 2.0   1.4e6
; tic &  bu = la.spilu(bb, permc_spec='MMD_AT_PLUS_A')   & toc   ; 0.6s
; tic &  bu = la.spilu(bb)   & toc
;tic & sol = la.cg(bb, atb_ok, tol=1e-6)   & toc ; 0.11s
; tic &    btu = la.splu(bbt, permc_spec='MMD_AT_PLUS_A')  & toc  ; 1.7     0.6e6
; tic &    btu = la.splu(bbt, permc_spec='MMD_AT_PLUS_A')  & toc  ; 1.7     0.6e6
;s1 =   btu.solve(atb_ok, trans='N')
;tic & tmp =  la.cg(bb, atb_ok, tol=1e-8) & s2=tmp[0]   & toc ; 0.11s
; cg veel veel sneller, maar check robustness. good second: spilu


;---------------- general utilities

; mophongo requires that basic astrometry and background is alread "close"
pro mophongo::load_detect, fdet

   if isa(fdet) then begin
      logger, 'loading '+fdet,/info

      self.fdet = fdet
      memmap = self.param.fit_memmap

      detimg = self.memmap(readfits(fdet, hdet, /silent,nan=0.0), name='det', file=memmap)
      self.detimg = ptr_new(detimg, /no_copy)

      extast, hdet, ast_det
      getrot, ast_det, pa, cdelt
      self.param.pscale_det = cdelt[1]*3600.

     ; @@@ change this, takes too much memory
      var = (readfits(fdet.replace('sci','rms'), /silent, nan=0.0))^2
      var = self.memmap(float(var ne 0.0)/(var + float(var eq 0)), name='detwht', file=memmap)
      self.detwht = ptr_new(var, /no_copy)

      ; @@@@ segmap will go.. or converted into objects file (or reverse index file)
      seg = self.memmap(readfits(fdet.replace('sci','seg'), /silent, nan=0.0), name='segmap', file=memmap)
      self.segmap = ptr_new(seg, /no_copy)

      self.fdetpsf = fdet.replace('sci.fits','psf.sav')
      detpsf = self.getpsf(1, 1, filename=self.fdetpsf)

      ; pre allocate model
      self.model = ptr_new(self.memmap(fltarr((*self.detimg).dim), name='model', file=memmap), /no_copy)
    end
end

pro mophongo::load_catalog, catfile

   ; @@@ naming of objects is inconsistent -> fix so similar to wht,rms et
   restore, catfile

   self.obj = ptr_new( obj[where(obj.use)] )

   ;!null = HISTOGRAM(*self.segmap,min=1,rev=ri)
   ;iseg = cgReverseIndices(ri, (*self.obj)[j].id-1, COUNT=cnt)
   ; ignore previous blends, note: IDs are not sequential,
   ; but assume index of original list is ID-1
   ; we would actually want to preserve and measure them, incase galaxies were erroneousl split up
end

; @@@@ catch missing files etc
; native pixel scale is: hi-resolution pixel scale, or integer binning of that
pro mophongo::load_photo, fphot

   if isa(fphot) then begin
      logger, 'loading '+fphot,/info

      self.fphot = fphot
      ptype = fphot.extract('sci|con')

      ; @@@@ 1) keep in memory when file is small, 2) memory mapped when larger
      ; 3) optional: dispense with mapping and do direct mrdfits from file
      photimg = readfits(fphot, hphot, /silent,nan=0.0)
      photimg = self.memmap(photimg, name='phot', file=self.param.fit_memmap)
      self.photimg = ptr_new(photimg,/no_copy)

      ; @@@@ 1) keep in memory when file is small, 2) memory mapped when larger
      ; 3) optional: dispense with mapping and do direct mrdfits from file

      wht = (readfits(fphot.replace(ptype,'rms'), /silent, nan=0.0))^2
      wht = float(wht ne 0.0)/(wht + float(wht eq 0))  ; @@@@ check if all whts have been redfined.
      ; if so -> just read in weight (=inv variance)
      wht = self.memmap(wht, name='photwht', file=self.param.fit_memmap)
      self.photwht = ptr_new(wht, /no_copy)

      extast, hphot, ast
      getrot, ast, pa, cdelt
      self.param.pscale_phot = cdelt[1]*3600.

      ; load kernel
      self.fkern = fphot.replace(ptype+'.fits','kern.sav')
      !null = self.getkernel(1, 1, filename=self.fkern, ast_kern=ast_kern)

      getrot, ast_kern, pa, cdelt
      self.param.pscale_kern = cdelt[1]*3600.
   end
end



pro mophongo::getproperty,  detimg=detimg, detwht=detwht, sources=sources, photwht=photwht, kernel=kernel, detpsf=detpsf, _Ref_Extra = Extra

 ;  if arg_present(photimg) then photimg=self.photimg
   if arg_present(detimg) then detimg=self.detimg
   if arg_present(photwht) then photwht=self.photwht
   if arg_present(detwht) then detwht=self.detwht
   if arg_present(sources) then sources=self.obj
   if arg_present(kernel) then kernel=self.kernel
   if arg_present(detpsf) then detpsf=self.detpsf
   if isa(self) then begin
      self->IDL_object::GetProperty, _Extra = extra
   end
end

pro mophongo::setproperty, name=name, fdet=fdet, fphot=fphot,  _Ref_Extra = Extra

  if isa(field) then self.field=field
  if isa(fast) then *self.fast=fast

   if isa(self) then begin
      if isa(name) then self.name=name

      self->IDL_object::GetProperty, _Extra = extra
  end
end

function mophongo::memmap, var, name=name, file=file, type=type, dim=dim
   compile_opt static

   if ~isa(var) and ~isa(dim) then return, !null
   if ~keyword_set(type) then type = size(var,/type,/l64)
   if keyword_set(file) then filename = cwd()+'mophongo_'+ (isa(name) ? name : '') +'_'+cmunique_id()+'.mem'

   if isa(var) then sz = size(var,/l64)
   if isa(dim) then sz = [dim.length, dim, type, product(dim,/integer)]

   nbytes = [0,1,2,4,4,8,8,0,0,0,0,0,0,4]
   if type eq 8 then begin
      length = sz[-1]*n_tags(var,/length)
      if keyword_set(var) then tmpl = var[0]
   end else length = sz[-1]*nbytes[sz[-2]]

   dim = [sz[1], sz[0] eq 1 ? 1 : sz[2]]
   logger, 'creating memory mapping ', name, filename, dim, type, length/1e6, 'MB'

   if keyword_set(filename) then begin
      OPENW, unit, filename, /GET_LUN
      POINT_LUN, unit, length - 1
      WRITEU, unit, 0b
      FREE_LUN, unit
   end

; @@@ seems to fail (size error) if name is set but not filename for type = structure
   if not keyword_set(name) then SHMMAP, size=sz, template=tmpl, GET_NAME=name, FILENAME=filename $
   else SHMMAP, name, size=sz, template=tmpl, FILENAME=filename

   if not keyword_set(filename) then filename = 'none'
   if isa(self.memseg) then *self.memseg = [*self.memseg, name] else self.memseg = ptr_new(name)
   if isa(self.memfile) then *self.memfile = [*self.memfile, filename] else self.memfile = ptr_new(filename)
   if isa(self.memtype) then *self.memtype = [*self.memtype, type] else self.memtype = ptr_new(type)
   if isa(self.memdim) then *self.memdim = [[*self.memdim], [dim]] else self.memdim = ptr_new(dim)

   varmap = SHMVAR(name)

   ; copy values if var exists
   if isa(var) then begin
      varmap[0,0,0,0,0,0] = var  ; @@@@ should take as many dimensions as in var -> use execute?
      undefine, var
   end

   return, varmap
end

;SHMUNMAP, name
;stop
;   if not keyword_set(name) then SHMMAP, size=size(var), template=var[0], GET_NAME=name, FILENAME=filename $
;   else SHMMAP, name,  template=var, FILENAME=filename
;   if not keyword_set(name) then SHMMAP, size=sz, type=type, GET_NAME=name, FILENAME=filename $
;   else SHMMAP, name, size=sz, type=type, FILENAME=filename ; , template=var
 ;  kdim = [405,405]
 ;  len = 9000L
 ;  var = replicate({tmpl_source, inherits source, tmpl:fltarr(kdim) },len)


pro mophongo::unmap, var, name=name, filename=filename
   compile_opt static

   undefine, var
   if keyword_set(name) then SHMUNMAP, name
   if keyword_set(filename) then FILE_DELETE, file_search(cwd()+'mophongo_'+name+'_*.mem')
end

pro testmap
   cube = fltarr(400,400,200)
   cubemap = mophongo.memmap(cube, name='c', filename='c')

   mophongo.unmap, cubemap, name='c', filename='c'

end

function mophongo::init, param, name=name
   ;   logger, 'Initializing... ',/info
   if isa(param, 'Dictionary') then self.param = param

   return, 1
end

pro mophongo::help
  help,self,/obj
end

pro mophongo::cleanup
end

pro mophongo::help
  help,self,/obj
end

; @@@@ 1 clean up code
; @@@@ push parameter business in param
; @@@@ set pixel scale to fdet pixelscale
PRO mophongo__DEFINE

 data = {mophongo, $
          name : '', $
          ID : 0L, $
          param : obj_new(), $
          catalog : ptr_new(), $  ; catalog
          starcat : ptr_new(), $  ; star catalog
          obj : ptr_new(), $  ; objects
          reverse_indices: ptr_new(), $
          model : ptr_new(), $    ; model image
          detimg : ptr_new(), $    ; detection image
          detwht : ptr_new(), $    ; detection weight, inverse variance
          segmap : ptr_new(), $    ; segmentation map
          photimg : ptr_new(), $   ; photometry img
          photwht : ptr_new(), $   ; photometry wht: unit, inverse variance
          fkern : '', $             ; from here on it can be pushed into param
          fdet : '', $      ; name currently loaded det images
          tmpl: ptr_new(), $    ; obsolete?
          fdetpsf: '', $
          fphot : '', $     ; name currently loaded phot images
          fphotpsf: '', $
          memseg : ptr_new(), $   ; photometry img
          memfile: ptr_new(), $    ; corresponding filename if mapped to disk
          memdim : ptr_new(), $    ; photometry img
          memtype : ptr_new(), $   ; photometry wht: unit, inverse variance
          inherits idl_object }
end


; its' fast!
;   b = randomn(seed,405,405)
;   ptic
;   for i=0,499 do a=fconvolve(b,det[*,*,i])
;   ptoc

;   ptic
;   for i=0,499 do a=fconvolve(b,detmap[*,*,0])
;   ptoc
;
 ;  timeit, 'a=det[*,*,bs(1000,len=1)]'      ; 0.00026
 ;  timeit, 'a=det_t[bs(1000,len=1),*,*]'    ; 0.00084
 ;  timeit, 'a=*basis[bs(1000,len=1)].det'   ; 7e-5
 ;  timeit, 'a=detmap[*,*,bs(1000,len=1)]'   ;

;   timeit, 'for j=0,99 do a=det[*,*,j]'     ; 0.006
;   timeit, 'for j=0,99 do a=det[j,*,*]'     ; 2.9
;   timeit, 'for j=0,99 do a=*basis[j].det'  ; 0.006
;   timeit, 'for j=0,99 do a=detmap[*,*,j]'  ; 0.006

;   timeit, 'a=fconvolve(b,b)'  ; 0.02

; uses Valike & Hogg 2016 Matched-filter polynomial centroiding ?
; now using ML fit of entire profile -> fast enough and very accurate
; so this procedure not used

function mophongo::getshift, ref, img, box=box, normalize=normalize
   if not keyword_set(box) then !null = growthcurve(img,rhalf=fwhm) else fwhm=box[0]

   dim  = ref.dim
   d2 = (dim[0]-1)/2.0

   ; correlation of object with matching template
   ccf = fconvolve(ref, img, /CORR)

   !null = max(ccf,imax)
   xpeak = imax mod dim[0]
   ypeak = imax mod dim[1]
   dx = xpeak - (dim[0]-1)/2.0
   dy = ypeak - (dim[1]-1)/2.0

 ;  cloc = ccf[xpeak-1:xpeak+1,ypeak-1:ypeak+1]  & cloc /= max(cloc)
;  !null = center(ccf[xpeak-15:xpeak+15,ypeak-15:ypeak+15], fwhm=2.0*fwhm, xshift=xshift, yshift=yshift)
  !null = center(ccf, fwhm=2.0*fwhm, xshift=xshift, yshift=yshift)

  if yshift*xshift eq 0.0 then begin
      m = apermask(ref.dim,3*fwhm,x,y)
      estimates=[0.0,10,fwhm,fwhm,d2,d2,0]
      par = replicate({fixed:0,tied:''}, 7)
      par[[0,2,3,6]].fixed = 1
      fitref = mpfit2dpeak(ref*m, pref, /gaussian, parinfo=par, estimates=estimates,status=status,errmsg=errmsg)
      fitimg = mpfit2dpeak(img*m, pimg, /gaussian, parinfo=par, estimates=estimates,status=status,errmsg=errmsg)
      xshift = pref[4]-pimg[4]
      yshift = pref[5]-pimg[5]
   ;   print, 'mpfit: ', xshift, yshift
       return, [xshift, yshift]
  end else   return, [dx+xshift, dy+yshift]

end


pro exploration_stuff
  ; foreach b, basis do wht = append(wht, *b.wht)
  ; kern = self.getkernel(1,1)
  ; sig = sqrt( 1.0/total(kern^2)/wht)
  ; sigpix = sqrt(1.0/wht)
;       1994        3172
;         769        1967

   mm = mag(basis.flux_iso,29)
   ibf = where(x_cg lt -3*sig, complement=iokf)
   ibr = where(x_cg lt -3*sig and mm lt 24, complement=iok)
   iokb  = where(x_cg gt 1000*sig)
   cgimage, model1, layout=[2,1,1],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[1994,3172],yr=[769,1967]
   cgplots, basis[ibf].x, basis[ibf].y, psym=1,color='red'
   cgplots, basis[ibr].x, basis[ibr].y, psym=1,color='yellow'
   cgplots, basis[iokb].x, basis[iokb].y, psym=1,color='green'
   cgimage, residual1,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[1994,3172],yr=[769,1967]
   cgplots, basis[ibf].x, basis[ibf].y, psym=1,color='red'
   cgplots, basis[ibr].x, basis[ibr].y, psym=1,color='yellow'
   cgplots, basis[iokb].x, basis[iokb].y, psym=1,color='green'
   cgtext, basis[iokb].x, basis[iokb].y, strn(basis[iokb].id),/data,color='green'

;   cgplothist, mm, col='red',bin=0.1, xrange=[12,29.5], layout=[2,1,1]
;   plothist, mm[ibf], col='red',/overplot,/fill,fcol='red', xrange=[12,29.5], bin=0.1

   basis = self.make_basis(src,id=6554L)
   self.make_normal, basis, ata, atb
   sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
   x_cg = sol[0]
   model1 = self.make_model(basis, x_cg, id=id, residual=residual1)

   self.make_normal, basis, ata, atb
   sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
   x_cg = sol[0]
   model2 = self.make_model(basis, x_cg, id=id, residual=residual2)
   b_6554.id = 9999
   basis = [b_6554,basis]

   self.make_normal, basis, ata, atb
   sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
   x_cg = sol[0]
   x_cg[ii] -= 10
   x_cg[-1] += 10
   bs = basis
   (*bs[ii].det) = shift(*bs[ii].det,-1,-1)
   (*bs[-1].det) = shift(*bs[-1].det,-1,-1)

   self.make_normal, basis, ata, atb
   sol = la.cg(ata, atb, tol=1e-8)

   model3 = self.make_model(basis, sol[0], id=id, residual=residual3)
;   model3 = self.make_model(basis, x, id=id, residual=residual3)
; stop
; stop

   ; add bases and rebuild normal eq
 ;  btmp = [basis[iokf],basis_bright]
   self.make_normal, btmp, ata, atb
   sol = la.cg(ata, atb, tol=1e-8)
   foreach b, btmp, i do if i eq 0 then wht = *b.wht else wht = [wht, *b.wht]
   stmp = sqrt( 1.0/total(kern^2)/wht)
   xtmp = sol[0]
   id = btmp.id

   model2 = self.make_model(btmp, xtmp, id=id, residual=residual2)
  ; xtmp[-20:-1] = xtmp[-20:-1]*2

    mm = mag(basis.flux_iso,29)
   ibf = where(x_cg lt -3*sig, complement=iokf)
   ibr = where(x_cg lt -3*sig and mm lt 24, complement=iok)
   iokb  = where(x_cg gt 1000*sig)
   cgimage, model1, layout=[2,1,1],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgplots, basis[ibf].x, basis[ibf].y, psym=1,color='red'
   cgplots, basis[ibr].x, basis[ibr].y, psym=1,color='yellow'
   cgplots, basis[iokb].x, basis[iokb].y, psym=1,color='green'
   cgimage, residual2,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgplots, basis[ibf].x, basis[ibf].y, psym=1,color='red'
   cgplots, basis[ibr].x, basis[ibr].y, psym=1,color='yellow'
   cgplots, basis[iokb].x, basis[iokb].y, psym=1,color='green'
   cgtext, basis[iokb].x, basis[iokb].y, strn(basis[iokb].id),/data,color='green'

stop
   model3 = self.make_model(btmp, xtmp, id=id, residual=residual3)
   cgimage, model1, layout=[2,1,1],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgimage, model2, layout=[2,1,1],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgimage, residual1,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgimage, residual2,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
   cgimage, residual3,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]

help,xtmp[-57:-1]/x_cg[iokb]

stop

   ibad = where(x lt -3*stmp, compl=iok)
   model2 = self.make_model(basis[iok], x_cg[iok], id=id, residual=residual)

sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
x_cg = sol[0]

ibad = where(x_cg lt -3*sig and mm gt 22,compl=iok)
model2 = self.make_model(basis[iok], x_cg[iok], id=id, residual=residual)

; remove bas and rebuuikld
self.make_normal, basis[iok], ata, atb
sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
x_cg = sol[0]

delvarx,wht
model3 = self.make_model(basis[iok], x_cg, id=id, residual=residual)

i= where(x_cg lt -3*median(sig))
ib = where(x_cg gt 200*median(sig))
cgimage, residual,layout=[2,1,2],/keep,/stretc,minv=-1e-4,maxv=1e-4,/axis,xr=[702,4598],yr=[150,2410]
cgplots, basis[i].x, basis[i].y, psym=1,color='red'
cgplots, basis[ib].x, basis[ib].y, psym=1,color='green'

;stop
;foreach b, basis do wht = append(wht, *b.wht)
;sig = sqrt( 1.0/total(kern^2)/wht)

mbg = model lt median(sigpix)/2
tvs,mbg*residual

tt = (mbg*residual)[1200:2800,900:2000]
tt = tt[where(tt ne 0)]
plothist,tt,xr=[-1e-4,1e-4]
histogauss, tt, gg
; - 3e-6, sigma 8e-6
stop



;;;;-------- investigate
a = ata.todense()
ia = where(a gt 1e-6)
plothist, alog10(a[ia]),bin=0.1,col='red'
; bump at -1 is probably background
; should strongly correlate with distance
dm = distance_measure([1#basis.x, 1#basis.y],/matrix)
plot, dm[ia], alog10(a[ia]),psym=3
plothist, dm[ia],bin=0.1,col='green'

ainv = invert(a)
;i abs(ainv) gt 1e-10

x_dinv = ainv ## atb
; print, ainv[0:5,0:5],form='(6g12.2)'
print, ainv[0:5,0:5]/6e-5,form='(6f10.2)'
print,median(sqrt(ddinv)) ; median error
plothist, sqrt(ddinv),bin=0.0005,col='red',xr=[0,0.05]
print,correlate(ainv[0:10,0:10]),form='(11f8.3)'
iok = where(abs(ainv) gt 1d-10)
plothist,alog10(abs(ainv[iok])),col='red'

plothist, dm[ia], bin=5,col='green'
plothist, dm[iok],bin=5,col='green',/fill,/overplot,fcolor='green'

iok = where(abs(ainv) gt 1d-10 and dm gt 0) ; now withouth diagnonal
; median expected error on inproduct
var = 2.0/total(kern^2)/median(wht)
maxa = max(a)
cgplot, ainv[ia]/var > (-9) < 9, a[ia]/maxa, psym=3,/ylog,yr=[1e-3,2],xr=[-10,10]
cgplot, ainv[iok]/var> (-9) < 9, a[iok]/maxa, col='red',/overplot,psym=3
vline, 1, yr=[0.001,1e2], linest=2
vline, -1, yr=[0.001,1e2], linest=2
hline, 0.5,  linest=1

; ok so we can cull on dotproduct -> if < 1e-3 of the diagonal? -> check for uberbright sources
iaok = where(a/max(a) gt 1e-3)
plothist, dm[ia], bin=5,col='green'
plothist, dm[iaok],bin=5,col='green',/fill,/overplot,fcolor='green'

a[where(a/max(a) lt 1e-3)] = 0
a[where(a/max(a) lt 1e-3)] = 0
ainv = invert(a)

; -----------------------
a = ata.todense()
ainv = invert(a)

ddinv = diag_matrix(ainv)
LA_SVD, A, W, U, V , /divide
x_dsvd = svsol(u,w,v,atb)
; ainv_svd =  v ## diag_matrix(w^(-1)) ## transpose(u) ; ok!
; lad = Python.import('scipy.linalg')
; x_svd = svsol(uwv[0],uwv[1],uwv[2],atb,/column) ; wrong answer ?
;condition = cond(ainv, /double, lnorm=2)
plot, w
print, 'condition ',max(w)/min(w), norm(ainv)*norm(a)
;print,(MACHAR(/double)).eps
;   2.2204460e-16

   la = python.import('scipy.sparse.linalg')
    sol = la.cg(ata, atb, tol=1e-8)   ; 0.06s
   x_cg = sol[0]

   x_sp = la.spsolve(ata, atb, permc_spec='MMD_AT_PLUS_A')  ; 0.18 s
;   ata_inv = la.inv(ata.tocsc())  ; forever

;   ilu = la.splu(ata,permc_spec='MMD_AT_PLUS_A')  ; 0.15
   ilu = la.spilu(ata,permc_spec='MMD_AT_PLUS_A')  ; 0.11
   x_ilu = ilu.solve(atb)

   !p.thick=2 & !x.thick=2 & !y.thick=2 & !p.multi=[0,2,1]
   cgplot, x_dinv, x_cg, psym=16, symsize=0.5, title='CG',xtitle='x_dinv',ytitle='(x_cg-x_dinv)/x_dinv'
   cgplot, x_dinv, (x_cg-x_dinv)/x_dinv, psym=16, symsize=0.5,xr=[-0.3,0.3],yr=[-0.05,0.05]
   print,stddev((x_cg-x_dinv)/x_dinv)

   cgplot, x_dinv, x_svd, psym=16, symsize=0.5, title='dSVD',xtitle='x_dsvd',ytitle='(x_dsvd-x_dinv)/x_dinv'
   cgplot, x_dinv, (x_dsvd-x_dinv)/x_dinv, psym=16, symsize=0.5,xr=[-0.3,0.3],yr=[-0.3,0.3]
   print,stddev((x_dsvd-x_dinv)/x_dinv)

   cgplot, x_dinv, x_sp, psym=16, symsize=0.5, title='SP',xtitle='x_sp',ytitle='(x_sp-x_dinv)/x_dinv'
   cgplot, x_dinv, (x_sp-x_dinv)/x_dinv, psym=16, symsize=0.5,xr=[-0.3,0.3],yr=[-0.3,0.3]
   print,stddev((x_sp-x_dinv)/x_dinv)

stop

  model = self.make_model(basis, x_cg)
; lots of very negative
   model = self.make_model(basis, x, id=id)

   x = where(x gt 0)
   model = self.make_model(basis, x, id=id)

; condition ? number ?
; check svd results and if negative fits correspond to those faint xxx

   ;    subphot, imphot, imseg, imtmpl, tmplpsf, kern, idsex[k], [1#xsex,1#ysex,1#idsex], imtmpl2,tmpl_snrlo=tmpl_snrlo,  tmpl2_snrlo=tmpl2_snrlo, $ ;  imphotw=imphotw,
   ;         rlim=subphot_rlim[iphot+1]/pixscl, raper=subphot_raper/pixscl, masksig=masksig, outdir=subphot_outdir, rms=subphot_rms, nomask=subphot_nomask, $
    ;;        maxshift=subphot_maxshift/pixscl,ftol=1e-8,   $
    ;        maxiter=20L, display=subphot_display, snrlo=subphot_snrlo, snrhi=subphot_snrhi, $
    ;        snrshift=subphot_snrshift, libnative=native, noaper=noaper, linear=linear, $
    ;        silent=silent, bg=subphot_bg, savefits=subphot_savefits, $
    ;         maskhi=subphot_maskhi, nsigma=subphot_nsigma,  $
    ;        photbin=floor(subphot_photbin/pixscl), himg=himg, sys_err = subphot_sys_err ;, stopme=stopme
    ;        ; @@@  extra doesnt work here: complains about Ambiguous keyword abbreviation: PHOT.toc

end

;   zm = rebin(reform(z[inn],1,inn.length),1e5,inn.length)
;   zm = rebin(reform(z[inn],1,inn.length),3,inn.length)
  ; print, kx(0.5,0.5,kxx)
; so [number of systems, coeff poly 2d]
  ; z = sin(x/2)*cos(y-0.5)
  ; p = PLOT(x, y, 's', RGB_TABLE=74, ASPECT_RATIO=1, /SYM_FILLED, VERT_COLORS=BYTSCL(z))


; d =  (x-xout[0])^2 + (y-yout[0])^2
; is = sort(d)
      ; timeit,'  h = hist2(x, y, min1=0, max1=1, min2=0, max2=1, bin1=1/sqrt(x.length), bin2=1/sqrt(x.length), ri=r)
      ; 6e-6
;      binx = 2/sqrt(x.length)
;      biny = 2/sqrt(x.length)
;      h = hist2(x, y, min1=0, max1=1, min2=0, max2=1, bin1=binx, bin2=biny, ri=r)
;   hdim = h.dim
;   ii = localindex(h, [[0,1,0],[1,1,1],[0,1,0]], ipix=floor(xoutx) + floor(youty)*hdim[0])
;   foreach i,ii do isel = [isa(isel) ? isel : !null, r[i] ne r[i+1] ? r[r[i]:r[i+1]-1] : !null ]
 ; i = floor(xoutx) + floor(youty)*hdim[0]
 ; isel = r[r[i]:r[i+1]-1]
;   plot, x, y, psym=1,/iso
;   cgplots, x[isel], y[isel], psym=9, col='red'
; coef = LA_LEAST_SQUARES(ut,transpose(zm))


pro testgrid

; linear in number of stars, pixels / nbasis, # output grid
     npos = 100L
     ci = randomn(seed,99,99,npos)
     ci = reform(ci,99*99L,npos)
     ci[*,0] = 10
     ci[0,*] = 10
     ci[-1,*] = -1
     ci[*,-1] = -1
     x = randomu(seed,npos)
     y = randomu(seed,npos)
     xout = findgen(10)/10.
     yout = findgen(10)/10.


a = match_2d(xout,yout,x,y,1/sqrt(x.length))
nbin = round(sqrt(x.length))
timeit, 'hist2d, x,y, h, [0,1], [0,1], nbin, nbin, reverse_indices=reverse_indices'
timeit, 'h=hist2(x, y, min1=0, max1=1, min2=0, max2=1, bin1=1/sqrt(x.length), bin2=1/sqrt(x.length), ri=ri)


     nmax = 5 ;  ; limiting and triangulate just makes it slower
     ncoef = (ci.dim)[0]
     s = fltarr(ncoef, xout.length, yout.length)
     TRIANGULATE, x, y, tr, con=ri
 timeit,'    for i=0,ncoef-1 do s[i,*,*] = griddata(x, y, ci[i,*], power=2, method=method, xout=xout,  yout=yout, /grid, _extra=extra)

;    xout = findgen(100)/10.
;    yout = findgen(100)/10.
; power = 2 is twice as fast
    ncoef = (ci.dim)[0]
     s = fltarr(ncoef, xout.length)
tic
     for i=0,ncoef-1 do s[i,*,*] = griddata(x, y, ci[i,*], power=2, method=method, xout=xout, $
          yout=yout,   _extra=extra)
toc

   xout = findgen(10)/10.
   yout = findgen(10)/10.
   ci2 = reform(ci,100,99*99L)
   s2 = fltarr(xout.length, yout.length,ncoef)
tic
    for i=0,ncoef-1 do s2[0,0,i] = griddata(x, y, ci2[*,i], power=2, method=method, xout=xout, yout=yout, /grid, triangles=tr, _extra=extra)
toc

   xout = findgen(10)/10.
   yout = findgen(10)/10.
   ci2 = reform(ci,100,99*99L)
   s2 = fltarr(xout.length, yout.length,ncoef)
   TRIANGULATE, x, y, tr
tic
   for i=0,ncoef-1 do s2[0,0,i] = griddata(x, y, ci2[*,i],  method=method, xout=xout, $
      yout=yout, /grid, triangles=tr, /radial, _extra=extra)
toc


   dx = xout[1]-xout[0]
tic
   s2 = grid_tps(x, y, ci,  ngrid=[xout.length,xout.length],start=[xout[0],yout[0]],delta=[dx,dx])
toc


   n = 15    ;# random points
   x = RANDOMU(seed, n)
   y = RANDOMU(seed, n)
   z = exp(-2 * ((x-.5)^2 + (y-.5)^2)) ;The gaussian

;   get a 26 by 26 grid over the rectangle bounding x and y:
   e = [ 0.25, 0.0]  ;Range and nugget are 0.25, and 0.
       ;(These numbers are dependent upon
       ;your data model.)
   r = krig2d(z, x, y, EXPON = e)  ;Get the surface.

   e = [ 0.25, 0.0]  ;Range and nugget are 0.25, and 0.
       ;(These numbers are dependent upon
       ;your data model.)
   r = krig2d(z, x, y, EXPON = e)  ;Get the surface


   a = randomu(seed,1000,1000)
   a = transpose(a) ## a
   b = randomn(seed,100)

   choldc, a, p                ;  1e-4
   Result = CHOLSOL(A, P, B)   ;  1e-5

   result = invert(a)          ;  1e-3
end


pro mktmplold
      ; central SNR in phot image, don't fit if too low ?
  ;     e_phot =  min(seg.dim/4.0)*sqrt(!pi/phot_ivar)
  ;    faper, phot_img, xpeak, ypeak, min(seg.dim/4.0), f_phot

     ;wtmpl = (*self.detwht)[s.xmin:s.xmax,s.ymin:s.ymax]
      ;a = (*s.img)[where(seg eq s.id)]
      ;print,total(a)
  ;   timeit, 'tmplc = convolve(kern,tmpl)'  ; @@@ test centering w/bright pixel
  ;   timeit, 'tmplc = fconvolve(kern,tmpl)'  ; @@@ test centering w/bright pixel
      ; check location ok! detect_showstamp ok!
      ; @@@ place a point source aperture mask over image
      ; @@@ calc SNR for point sources within a FWHM disks
      ; do fit on cut-out
 ;     aa = tmplc[kloc[0]:kloc[0]+tsz[0]-1,kloc[1]:kloc[1]+tsz[1]-1]  ; NB: offsets have to be correct!
 ;     aa /= total(aa)
;self.detimg[]
;help,
;id = idlist[20]
;timeit, 'foreach id, idlist do tmp = h[id]'
;foreach id, idlist do tmp = h[id]

  obj = fltarr(tsz,tsz,len)
  npix = long(tsz*tsz)
  ix = long(x)
  iy = long(y)
  s2 = (tsz-1)/2              ; shift for fft = half tile size

  dxy = [1#(x-ix), 1#(y-iy)]  ; fractional pixel offset
  rxy = s2 + dxy              ; exact coordinates in tile
  ll = long([1#ix,1#iy]-s2)   ; coordinates of lowerleft pixel  (offset of tile in image)

 ;:::klen = (size(km))[2]
; klen = (size(km))[3]         ; number of kernels used
; xg = lindgen(tsz)


; don't do shifts here. -> keep kernel perfectly centred
 ;#### how to get the shiftmapped kernels?
; if keyword_set(sm) then begin
  ; slen = (size(sm))[2]
  ; sx =  sm[0,*]
  ; sy =  sm[1,*]
   ;@@@ check interpol map
 ;  stop
;   coeff_sh= reform(interpol_map(km[0,*], km[1,*], km[2:*,*], sx, sy))
;   sm = fltarr(4,klen)
;   sx = gx; + rxy[0,*]; km[0,*]
;   sy = gy                      ; + rxy[1,*]; km[1,*]
;   slen = klen
; end else begin
;   ;coeff_sh= km[2:*,*]
;   sm = fltarr(4,klen)
;   sx = gx; + rxy[0,*]; km[0,*]
;   sy = gy; + rxy[1,*]; km[1,*]
;   slen = klen
; end

; alternative: use kernel in real space and fft in the loop. take a little speed hit, but
 ; yields another 400 MB or so
 ; find kernel coefficients on the shift map (which is probably higher spatial resolution)
 ; Basically putting getkern from doall.pro in here so  ; the kernel map from mkkern is used instead.
; Dont do any shifts here. It will be done after hte first step, in the prep stage


 if not keyword_set(silent) then print, 'mktmpl: building kernel map'
 ft_kern_map = complexarr(tsz, tsz, slen)
 for i=0L, slen-1 do begin &$
   ;kern = interpolate(mkmodel(basis,coeff_sh[*,i]), xg-sm[2,i], xg-sm[3,i], /grid, missing=0.) &$
    kern = interpolate(km[*,*,i], xg-sm[2,i],xg-sm[3,i], /grid, missing=0.0)
    ft_kern_map[*,*,i] = fft(kern/total(kern)) &$

 end
 ;use restore, "/Users/mark/mophongo/example/out_put/psf/kern_CDFS-1_Ks_v0.9.4_sci_CDFS_CH1.sav"
 ;ft_kern_map = complexarr((size(kernel))[1],(size(kernel))[2],(size(kernel))[3])
 ;ft_kern_map = fft(kernel/total(kernel))

 ; prepare interpolation, by expressing x,y in terms of sx,sy bins
 xout = sx[uniq(sx,sort(sx))]
 yout = sy[uniq(sy,sort(sy))]
 nx = n_elements(xout)
 ny = n_elements(yout)
 xstep = (max(sx)-min(sx))/(nx-1.)
 ystep = (max(sy)-min(sy))/(ny-1.)
 gx = reform(sx,nx,ny)
 gy = reform(sy,nx,ny)
; get index of x,y in regular grid
 xs = (x-xout[0])/xstep
 ys = (y-yout[0])/ystep

; this is hacky
; psf = (readfits('psf_k.fits'))[19:83,19:83]
 if keyword_set(fwhm1) then begin
   psf = psf_moffat(NPIXEL=(tsz+0.), FWHM=fwhm1, beta=3.,/norm)
   print, 'adding PSF profile with fwhm',fwhm1,' outside segmap for faintest sources'
 end

 ; @@@@@@@@@ this would be a good place to calc aperture correction as a function
 ; of radius
; showme=1

 xind = lindgen(tsz)
 kmap_reform =  reform(ft_kern_map,tsz*tsz,nx,ny)
  if not keyword_set(silent) then print, 'mktmpl: populating obj vector'
  for i=0L, len-1 do begin
    t1 = extrac(img1,ll[0,i],ll[1,i],tsz,tsz)
    t2 = extrac(img2,ll[0,i],ll[1,i],tsz,tsz)
    s1 = extrac(seg1,ll[0,i],ll[1,i],tsz,tsz)

    ; make template from pixels in segmap only, force positivity
   ;  o =  t1*(s1 eq id[i]) > 0.     ; this leaves negative peaks
   ; try to make template from everything except the other ids
    mask_nn = growmask(s1 eq id[i] or s1 eq 0)  ; neighbours are 0
    mask_obj = s1 eq id[i]
    isegpix = where(mask_obj, nsegpix)

    ; grow segmap
;    for j=0L,ngrow-1 do mask_obj = growmask(mask_obj,/inver)
;    mask = mask_obj*mask_nn

    ; add point source profile outside the segmentation map
    ; @@@ need to do this to calculate the aperture correction too!!!
    if nsegpix lt minsegpix and keyword_set(psf) then begin
   ;   tvrscl, t1*mask_obj, mm=[-10,10], pos=0
      psf_i = interpolate(psf, xind-dxy[0,i], xind-dxy[1,i],/grid)
      fscale = total(t1*mask)/total(psf*mask)
      o = (t1*mask+ (1-mask)*fscale*psf) > 0.
    end else o = (t1*mask) > 0.

    ; @@ not just faster to do filter image noconf?
    ; interpolate kern/shift map to x,y of object

; @@@ we do not register the kernel -> leading to 0.3 pix scatter on high-res image
; @@@ what is relevant is the 0.3 pix rms / FWHM_low

    ; note we are doing circular (FFT) transform, with some padding.
    ; note: the size needs to be odd

; lets suppose 170 x 170 kernel

    ft_kern_i = reform(interpolate(kmap_reform, xs[i],ys[i]),tsz,tsz)
    ; do all multiplications and FFTs in doubles  @@@ why?
    ft_o = fft(double(o))
;    ft_kern =  dcomplex(ft_kern_i)
    ; convolve with shifted kernel; where shift and kernel are interpolated to x,y
    m = shift( npix * double( FFT( ft_o * dcomplex(ft_kern_i), 1 ) ), s2+1, s2+1) ; i dont know
    obj[0,0,i] = m

   end ; for obj

   help,/mem, out=mem
   m=float((strsplit(mem,/ex))[3])/(1024.)^2.
   print, systime(1) - time1 ,' SECONDS, ', m,' MB MEMORY'
end ; end proc


pro junk
;cout = interpolate(cimg, indgen(dim[0])-(d2 - xc0),indgen(dim[1])-(d2 - yc0), missing=missing, /GRID, cubic=cubic)
; stopkey
;return, warp_image(img, 0, 1.0, (dim[0]-1.0)/2 + xshift,  (dim[1]-1.0)/2 + yshift)
;   iok = where(m)
 ;  cc = double(QUARTICFIT( X[iok], Y[iok], ccf[iok] ,0., YFIT))
 ;  imfit = m*0.0
 ;  imfit[iok]  = yfit

;   tvs, ref*m
; check using peak pixel
   !null = max(ref*m,imax)
   print, 'peak: ', imax mod dim[0], imax / dim[0], '    -> ', imax mod dim[0] - d2, imax / dim[0] - d2
   !null = max(ccf*m,imax)
   print, 'peak: ', imax mod dim[0], imax / dim[0], '    -> ', imax mod dim[0] - d2, imax / dim[0] - d2

; check using gcntrd
   !null = center(ref*m, fwhm=oddsize(3*fwhm), /check, cxy=cxy, xshift=xshift, yshift=yshift)

   ; fit parabola to cross correlation function
   sig = mad(double(ref))
   aam = reform([ [[2*cc[2]],[cc[3]]] , [[cc[3]],[2*cc[5]]] ],2,2)
   bb = 2.0*[-cc[1],-cc[4]]
   sh = invert(reform(aam,2,2)) ## bb
   x_shift = sh[0]
   y_shift = sh[1]

print, 'QF:', sh, form='(a,2g12.4)'
print, 'SH:', xshift, yshift

stopkey
;return, warp_image(img, 0, 1.0, d2 + x_shift, d2 + y_shift)

print, ' REF IMG CCF'
   delvarx, cxy
   m = apermask(ref.dim,2*fwhm)
stop
   !null = center(ref*m, fwhm=oddsize(3*fwhm), /check, cxy=cxy, xshift=xshift, yshift=yshift)
   if yshift*xshift eq 0.0 then begin
      cntrd, img*m, (dim[0]-1)/2.0, (dim[1]-1)/2.0, xc, yc, 3*fwhm
      cxy = [xc,yc]
   end
   img_align = center(img, fwhm=oddsize(3*fwhm), /check, cxy=cxy, xshift=xshift, yshif=yshift)
   if yshift*xshift eq 0.0 then begin
      cntrd, img*m, (dim[0]-1)/2.0, (dim[1]-1)/2.0, xc, yc, 3*fwhm
      xshift = xc - (dim[0]-1)/2.0
      yshift = yc - (dim[1]-1)/2.0
         end
print, cxy
print,xshift, yshift
;return, img_align

; good size and proportion, but what is normalization of shift?
; is related to number of kernel elemends considered ?
  ; gcntrd, ccf, (dim[0]-1)/2.0, (dim[1]-1)/2.0, xcen, ycen, oddsize(3*fwhm)
;   mkgrid, ref.dim, x, y
;   iok = where(apermask(ref.dim,2*fwhm))
;   cc = double(QUARTICFIT( X[iok], Y[iok], ccf[iok] ,0., YFIT))
;   ; FR a + bX + cX^2+dXY + eY  + fY^2
;   ; V&H a + bx + cy + dx2 + exy + f y2
;   sig = mad(double(ref))
;   aam = [[2*cc[2]+1e-4*sig],[cc[3]],[cc[3]],[2*cc[5]+1e-4*sig]]
;   bb = [-cc[1],-cc[4]]
;print, 'QF:', invert(reform(aam,2,2)) ## bb, form='(a,2g12.4)'
;print, 'SH:', xshift, yshift

   if yshift eq 0.0 and xshift eq 0.0 then begin
     cntrd, img, (dim[0]-1)/2.0, (dim[1]-1)/2.0, xc, yc, 3*fwhm
        if xc[0] ne -1 and yc[0] ne -1 then begin
         xshift = xc - (dim[0]-1)/2.0
         yshift = yc - (dim[1]-1)/2.0
         cxy = [xc,yc]
      end
    end

;stopkey
;return, warp_image(img, 0, 1.0, (dim[0]-1)/2.0 + xshift, (dim[1]-1)/2.0 + yshift)
;return, center(img, fwhm=oddsize(3*fwhm),cxy=cxy,missing=0.0,/check)
end


  ;  if (id[i] eq 10001L) and keyword_set(stopme) then begin
;			delvarx,mm,mm1;
;;			tvrscl, t1, os=3, pos=0,mm=mm1;
	;		tvrscl, t2, os=3, pos=1,mm=mm;
	;		tvrscl, s1, os=3, pos=2,mm=[0,1]
;			tvrscl, o, os=3, pos=3,mm=mm1*5
;			tvrscl, m, os=3, pos=4,mm=mm1;
	;		writefits, 'object_check_tmpl.fits', t1
;			writefits, 'object_check_tmpl_seg.fits', o;
	;		writefits, 'object_check_tmpl_seg_conv.fits', m
	;		print,mm1
	;		tvrscl, t2-m*max(t2*mask)/max(m), os=3, pos=5,mm=mm
	;		stop
   ; end

   ; chart diffence between kernel0 and kernel_xy as a function of dx dy
   ;  m0 = shift( npix * float( FFT( ft_o * ft_kern0, 1 ) ), s2+1, s2+1) ; i dont know
   ;  diff[i] = total(abs(m-m0))/(total(m0) > 1e-6)
   ;  distx[i] = (kxy[0]-x[i])
   ;  disty[i] = (kxy[1]-y[i])

    ; tvs, self.shift(phot,dxy_psf[0,i],dxy_psf[1,i])-dxy_psf[2,i]*model,mm=[-1,1]*1e-4
      ; tvs, self.shift(phot,-0.3,-1.08)-0.82*model,mm=[-1,1]*1e-4
      ; 2 parameter x,y ('dot product PSF' from Vakili+16)
      ; only marginally faster and less robust to neighbors
      ;      p = mpfit('centroid_psf', [0.,0.], ftol=1e-5, parinfo=parinfo[0:1], STATUS=status, $
      ;               nfev=nfev, BESTNORM=chi2, covar=covar, perror=perror, dof=dof, ERRMSG=errmsg, $
      ;               quiet=1, functargs={  err:sqrt(1.0/median(wht)), obs:phot, model:model} )
      ;      logger, 'dot:', b.id, p, perror, chi2, nfev
      ;stopkey
;   ata = Python.ata
;  bb = ata.todense()   ; single, not symm
; nice
;plothist,alog10(bb),col='red', xr=[-6,4.5],bin=0.07
; plothist,alog10(ata.diagonal()),col='green',/overplot,bin=0.07
;  basis[j].nchildren=ncol -> j+icol -> get distances from sij -> what is that structure, what sources?
; plot, bb, vs rr

;plot,w  ; -> check faintest 15% eigenvalues ! break at ~830
;  solve dense
;  bb = ata.todense()
;  ata_inv = invert(bb)
;svdc, bb, w, u, v        ; takes 4 x LA_LEAST
;res_svd = svsol(u,w,v,b)  ; takes zero time
; plothist,alog10(sqrt(ata_inv)),col='blue'  ;, xr=[-6,4.5]
; bta_full = bb.todense()
; ok !
;   ata_full = ata.todense(order='C') > 0
;   ata_full =  ata_full + transpose(ata_full) -  diag_matrix(ata.diagonal())
; tvs, alog10(ata_full>1),mm=[-1,max(alog10(ata_full))]
; tvs, alog10(bta_full>1),mm=[-1,max(alog10(ata_full))]
 ;  print, 'ATA nonzero elements: ', ata.count_nonzero()
 ;  Python.Run, 'import numpy as np'
 ;;  Python.Run, 'ata.count_nonzero()*1.0/np.prod(ata.shape)'
 ;  stop
;      toc
;     mpfit -> replaced by linear basis functions
;     tvs, (phot-model)[k4:3*k4,k4:3*k4], mm=[-1,1]*1e-4
;      tvs, clean4-lin4, pos=1, mm=[-1,1]*1e-4
;      faper, ((clean4-lin4)/medsigpix)^2, !null, !null, rhalf_phot*0.06, fresn
;      print, reform(xx)
      ;    shx = (shift(aa[2,*],1,0)-shift(aa[2,*],-1,0))/2.0
      ;     shy = (shift(aa[2,*],0,1)-shift(aa[2,*],0,-1))/2.0

      ;  first  check if model already very similar to PSF!
;      parinfo[2:3].limits = [-0.2,1.2]*scale  ; flux limits on each component
;      dxy = mpfit('add_model', [0.,0., 0.0, scale], ftol=1e-5, parinfo=parinfo, $
;               STATUS=status, nfev=nfev, BESTNORM=chi2, covar=covar, perror=perror, dof=dof, $
;               ERRMSG=errmsg, quiet=1, functargs={  err:sqrt(1.0/(*b.wht)), $
;               residual:clean[k4:3*k4,k4:3*k4],  model2:psf[k4:3*k4,k4:3*k4], $
;                model1:(*b.det)[k4:3*k4,k4:3*k4], stopme:0 } )
;      ;toc
;      new_model = dxy[2]*self.shift(psf,dxy[0],dxy[1]) + dxy[3]*(*b.det)
      ;tvs, phot-model, mm=[-1,1]*1e-4
;      print,dxy[0],dxy[1],dxy[3],dxy[2]
;      if fresnew / fresi lt 0.66 then print, ' @@@@ keeping new MPFIT'
;      tvs, (clean - new_model)[k4:3*k4,k4:3*k4], pos=2,  mm=[-1,1]*1e-4
;     faper, (((clean - new_model)/medsigpix)^2), !null, !null, rhalf_phot*0.06, fresnew
      ; only accept if signiticantly better


; defining all internal data as a hash
;
;pro myclass::setproperty, _extra=extra
;  compile_opt idl2, logical_predicate
;
;  d = self.d
;
;  if (~n_elements(extra)) then return
;  n = n_elements((tags=tag_names(extra)))
;
;  for i=0, n-1 do begin
;     d[tags[i]] = extra.(i)
;  endfor
; end
;pro myclass::getproperty, _ref_extra=extra
; compile_opt idl2, logical_predicate
;
; d = self.d
; if (~n_elements(extra)) then return;
;
; for i=0, n_elements(extra)-1 do begin
;    (scope_varfetch(extra[i], /ref_extra)) = d[extra[i]]
; endfor
;end




;	  {	    ;
;	    ii=0;
;	    for (n = yomin; n <= yomax; n++) {
;	      jj=0;
;	      for (m = xomin; m <= xomax; m++) {
;		if(Mask[(n-CellYl)*CellXdim+(m-CellXl)]>0){
;		  sigma2=pixels_rms[n*Width+m];
;		  sigma2=sigma2*sigma2;
;#ifdef DEBUG
;		  if (sigma2<1.e-10)
;		    {printf("TERROR: sigma - %d %d %d %d %ld %ld, %f\n",m,n,ii,jj,Width,n*Width+m,sigma2);}
;#endif
;		  temp1=pixels_th1[(y_in1+ii)*columns1+(x_in1+jj)];
;		  temp2=pixels_th2[(y_in2+ii)*columns2+(x_in2+jj)];
;		  //if (usemask) {if (temp1<TOL && temp2<TOL) {temp1=0.0; temp2=0;}}
;		  //if (temp1>Threshold1 && temp2>Threshold2) a[i][j] += (temp1*temp2) / sigma2;
;		  if (temp1>Threshold1) a[i][j] += (temp1*temp2) / sigma2;
;		}
;		jj++;
;	      }
;	      ii++;
;	    }
;	  }
;;
;#ifdef FLUXPRIOR;
;	if (i==j)
;	  {
;	    a[i][j] += pCatalog1->fpf/pow(pCatalog1->epf,2);;
;	  }
;#endif  :: RIGHT HAND
;     {
;	ii=0;
;	for (n = ymin1; n <= ymax1; n++) {
;	  jj=0;
;	  for (m = xmin1; m <= xmax1; m++) {
;	    if(Mask[(n-CellYl)*CellXdim+(m-CellXl)]>0){
;	      sigma2=pixels_rms[n*Width+m];
;	      sigma2=sigma2*sigma2;
;	      temp1 = pixels_th1[(y_in1+ii)*columns1+(x_in1+jj)];
;	      if (sigma2<=0.0){
;		printf("sigma2: %f %d %d %d\n",pixels_rms[n*Width+m],n,m,Width);exit(1);}
;	      if (temp1>Threshold1) b[i] += (temp1 * pixels[n*Width+m] ) / sigma2 ;
;	    }
;	    jj++;
;	  }
;	  ii++;
;	}}
;
;#ifdef FLUXPRIOR
 ; ;  b[i] += pCatalog1->fpf*pCatalog1->pf/pow(pCatalog1->epf,2);
;#endif

;dec = python.import('sklearn.decomposition')
;model = dec.NMF(init='random', solver='cd', tol=1e-8, alpha=0.0, l1_ratio=0.5)
;model.fit(ata,atb)

;kernel = create_kern(basis, coeff, /norm)
; imc = convolve(img1,kernel_r)
; imc /= total(imc)
;  tvs, img1, mm=[-1,1]*1e-3
;  tvs, img2, mm=[-1,1]*1e-3, pos=1
;  tvs, kernel, mm=[-1,1]*1e-3, pos=2
;  tvs, imc, mm=[-1,1]*1e-3, pos=3
;  tvs, img2-imc, mm=[-1,1]*1e-3, pos=4
;

;  coeff = float(la_least_squares(lax, reform(fft2,len), residual=lares))
  ; my wrapper for nnls, only call if more than 1 source (crashes otherwise)
;  lax_ri = [[real_part(lax)],[imaginary(lax)]]
;  fft2_ri = [[real_part(fft2)],[imaginary(fft2)]]
; coeff_ri = la_least_squares(lax_ri, reform(fft2_ri,len*2L), residual=lares)
; b = [reform(fft2_ri,1,len*2L),reform(fft2_ri,1,len*2L)/2]
; coeff_ri2 = la_least_squares(lax_ri, b, residual=lares)
; ifl_nnls, lax_ri, reform(fft2_ri,len*2L), coeff_ri2, res

;t1=systime(1)
;for i=0,10 do  coeff = float(la_least_squares(lax, reform(fft2,len), residual=lares))
;t2=systime(1)
;for i=0,10 do  coeff_ri = la_least_squares(lax_ri, reform(fft2_ri,len*2L), residual=lares)
;print, t2-t1,systime(1)-t2



